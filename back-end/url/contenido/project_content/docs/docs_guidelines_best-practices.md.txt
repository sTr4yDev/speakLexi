# ARCHIVO: docs/guidelines/best-practices.md
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/best-practices.md
# FECHA DESCARGA: 2025-10-28 22:57:25
# ==================================================

# üåü Mejores Pr√°cticas y Prevenci√≥n de Errores - SpeakLexi

> **Documento basado en errores reales del proyecto**  
> Este documento te ayudar√° a evitar los problemas m√°s comunes que han ocurrido durante el desarrollo.

---

## üö® Errores Cr√≠ticos y C√≥mo Evitarlos

### 1. **Error: CORS - No 'Access-Control-Allow-Origin' header**

#### ‚ùå Problema Com√∫n
```python
# app.py - Configuraci√≥n incorrecta de CORS
from flask_cors import CORS

app = Flask(__name__)
CORS(app)  # ‚ùå Demasiado permisivo o restrictivo
```

#### ‚úÖ Soluci√≥n Correcta
```python
# app.py - Configuraci√≥n espec√≠fica y segura
from flask_cors import CORS

CORS(app, resources={
    r"/api/*": {
        "origins": ["http://localhost:3000"],  # Frontend espec√≠fico
        "methods": ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"],
        "supports_credentials": True  # Si usas cookies/sesiones
    }
})
```

#### üîç Verificaci√≥n
```bash
# Probar desde el navegador
fetch('http://localhost:5000/api/usuarios', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json'
  }
})
```

---

### 2. **Error: 405 Method Not Allowed**

#### ‚ùå Problema Com√∫n
```python
# routes/usuario_routes.py
@usuario_bp.route('/perfil', methods=['GET'])  # ‚ùå Solo GET definido
def actualizar_perfil():  # ‚ùå Pero el frontend env√≠a POST
    data = request.get_json()
    # ...
```

#### ‚úÖ Soluci√≥n Correcta
```python
# Definir todos los m√©todos necesarios
@usuario_bp.route('/perfil', methods=['GET', 'PUT', 'PATCH'])
def gestionar_perfil():
    if request.method == 'GET':
        return obtener_perfil()
    elif request.method in ['PUT', 'PATCH']:
        return actualizar_perfil()

# O mejor, separa en rutas diferentes
@usuario_bp.route('/perfil', methods=['GET'])
def obtener_perfil():
    pass

@usuario_bp.route('/perfil', methods=['PUT', 'PATCH'])
def actualizar_perfil():
    pass
```

---

### 3. **Error: AttributeError: 'NoneType' object has no attribute**

#### ‚ùå Problema Com√∫n
```python
# services/gestor_usuarios.py
def obtener_usuario(usuario_id):
    usuario = db.session.query(Usuario).filter_by(id=usuario_id).first()
    return usuario.to_dict()  # ‚ùå Si usuario es None, explota aqu√≠
```

#### ‚úÖ Soluci√≥n Correcta
```python
def obtener_usuario(usuario_id):
    usuario = db.session.query(Usuario).filter_by(id=usuario_id).first()
    
    if not usuario:
        raise UsuarioNoEncontradoError(f"Usuario {usuario_id} no existe")
    
    return usuario.to_dict()

# En la ruta
@usuario_bp.route('/<int:usuario_id>', methods=['GET'])
def get_usuario(usuario_id):
    try:
        resultado = gestor_usuarios.obtener_usuario(usuario_id)
        return jsonify(resultado), 200
    except UsuarioNoEncontradoError as e:
        return jsonify({'error': str(e)}), 404
    except Exception as e:
        return jsonify({'error': 'Error interno'}), 500
```

---

### 4. **Error: SQLAlchemy - (OperationalError) no such table**

#### ‚ùå Problema Com√∫n
```python
# Olvidar ejecutar db.create_all()
from config.database import db
from models.usuario import Usuario

# ‚ùå No se crean las tablas
usuario = Usuario(nombre="Test")
db.session.add(usuario)
db.session.commit()  # ‚ùå Error: tabla no existe
```

#### ‚úÖ Soluci√≥n Correcta
```python
# app.py - Asegurar creaci√≥n de tablas
def create_app():
    app = Flask(__name__)
    db.init_app(app)
    
    with app.app_context():
        try:
            db.create_all()  # ‚úÖ Crear tablas si no existen
            print("‚úÖ Tablas creadas correctamente")
        except Exception as e:
            print(f"‚ùå Error al crear tablas: {e}")
    
    return app
```

#### üîç Verificaci√≥n
```bash
# Conectarse a MySQL y verificar
mysql -u root -p
USE SpeakLexi;
SHOW TABLES;  # Debe mostrar: usuarios, perfiles_usuario, etc.
```

---

### 5. **Error: JWT - Token has expired / Invalid token**

#### ‚ùå Problema Com√∫n
```python
# Frontend - No manejar tokens expirados
const response = await fetch('/api/usuarios/perfil', {
  headers: {
    'Authorization': `Bearer ${token}`  // ‚ùå Token expirado
  }
});
// ‚ùå No hay manejo de error 401
```

#### ‚úÖ Soluci√≥n Correcta
```python
# Backend - Validar y devolver error claro
from flask_jwt_extended import jwt_required, get_jwt_identity
from jwt.exceptions import ExpiredSignatureError

@usuario_bp.route('/perfil', methods=['GET'])
@jwt_required()
def obtener_perfil():
    try:
        usuario_id = get_jwt_identity()
        # ...
    except ExpiredSignatureError:
        return jsonify({'error': 'Token expirado', 'code': 'TOKEN_EXPIRED'}), 401
```
```tsx
// Frontend - Manejar renovaci√≥n de token
async function fetchConAuth(url: string) {
  const token = localStorage.getItem('token');
  
  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  
  if (response.status === 401) {
    const data = await response.json();
    
    if (data.code === 'TOKEN_EXPIRED') {
      // Redirigir a login o renovar token
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
  }
  
  return response;
}
```

---

### 6. **Error: Contrase√±as en Texto Plano**

#### ‚ùå Problema Com√∫n
```python
# models/usuario.py - ¬°NUNCA HAGAS ESTO!
class Usuario(db.Model):
    password = db.Column(db.String(255))  # ‚ùå Texto plano
    
    def verificar_password(self, password):
        return self.password == password  # ‚ùå Comparaci√≥n directa
```

#### ‚úÖ Soluci√≥n Correcta
```python
# models/usuario.py
from werkzeug.security import generate_password_hash, check_password_hash

class Usuario(db.Model):
    password_hash = db.Column(db.String(255))  # ‚úÖ Hash almacenado
    
    def set_password(self, password):
        """Hashea la contrase√±a antes de guardar"""
        self.password_hash = generate_password_hash(password)
    
    def verificar_password(self, password):
        """Verifica contrase√±a contra el hash"""
        return check_password_hash(self.password_hash, password)
    
    def to_dict(self):
        """NUNCA incluir password_hash en respuestas"""
        return {
            'id': self.id,
            'nombre': self.nombre,
            'email': self.email
            # password_hash NO se incluye
        }
```

---

### 7. **Error: Validaci√≥n de Entrada Faltante**

#### ‚ùå Problema Com√∫n
```python
# routes/auth.py - Sin validaci√≥n
@auth_bp.route('/registro', methods=['POST'])
def registro():
    data = request.get_json()
    
    # ‚ùå Asumir que los datos son correctos
    usuario = Usuario(
        nombre=data['nombre'],
        email=data['email']
    )
    db.session.add(usuario)
    db.session.commit()
```

#### ‚úÖ Soluci√≥n Correcta
```python
# routes/auth.py - Con validaci√≥n
from marshmallow import Schema, fields, validate, ValidationError

class RegistroSchema(Schema):
    nombre = fields.Str(
        required=True, 
        validate=validate.Length(min=2, max=100)
    )
    email = fields.Email(required=True)
    password = fields.Str(
        required=True,
        validate=validate.Length(min=8, max=128)
    )

@auth_bp.route('/registro', methods=['POST'])
def registro():
    schema = RegistroSchema()
    
    try:
        # Validar datos de entrada
        data = schema.load(request.get_json())
    except ValidationError as err:
        return jsonify({
            'error': 'Datos inv√°lidos',
            'detalles': err.messages
        }), 400
    
    # Validaciones de negocio adicionales
    if gestor_usuarios.email_existe(data['email']):
        return jsonify({'error': 'Email ya registrado'}), 409
    
    # Procesar registro
    resultado = gestor_usuarios.registrar(data)
    return jsonify(resultado), 201
```

---

### 8. **Error: SQL Injection (Aunque SQLAlchemy protege, es importante saberlo)**

#### ‚ùå Problema Com√∫n (Si usaras SQL crudo)
```python
# ‚ùå NUNCA HAGAS ESTO
email = request.args.get('email')
query = f"SELECT * FROM usuarios WHERE email = '{email}'"
resultado = db.session.execute(db.text(query))
# Vulnerable a: email = "'; DROP TABLE usuarios; --"
```

#### ‚úÖ Soluci√≥n Correcta
```python
# ‚úÖ Usar ORM de SQLAlchemy (protecci√≥n autom√°tica)
email = request.args.get('email')
usuario = Usuario.query.filter_by(email=email).first()

# ‚úÖ O con par√°metros si usas SQL crudo
query = db.text("SELECT * FROM usuarios WHERE email = :email")
resultado = db.session.execute(query, {'email': email})
```

---

### 9. **Error: Frontend - No manejar estados de carga**

#### ‚ùå Problema Com√∫n
```tsx
// components/auth/LoginForm.tsx
export function LoginForm() {
  const handleSubmit = async (e) => {
    const response = await fetch('/api/auth/login', {...});
    // ‚ùå Sin indicador de carga
    // ‚ùå El bot√≥n puede clickearse m√∫ltiples veces
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <Button type="submit">Iniciar Sesi√≥n</Button>
    </form>
  );
}
```

#### ‚úÖ Soluci√≥n Correcta
```tsx
export function LoginForm() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        throw new Error('Error al iniciar sesi√≥n');
      }
      
      const result = await response.json();
      // Manejar √©xito
      
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {error && <Alert variant="destructive">{error}</Alert>}
      
      <Button 
        type="submit" 
        disabled={loading}
      >
        {loading ? 'Cargando...' : 'Iniciar Sesi√≥n'}
      </Button>
    </form>
  );
}
```

---

### 10. **Error: Variables de Entorno No Cargadas**

#### ‚ùå Problema Com√∫n
```python
# config/settings.py
import os

# ‚ùå Sin load_dotenv(), las variables no se cargan
DB_HOST = os.getenv('DB_HOST', 'localhost')
```

#### ‚úÖ Soluci√≥n Correcta
```python
# config/settings.py
import os
from dotenv import load_dotenv

# ‚úÖ Cargar variables de entorno PRIMERO
load_dotenv()

# Ahora s√≠ funcionan
DB_HOST = os.getenv('DB_HOST', 'localhost')
DB_PORT = os.getenv('DB_PORT', '3306')

# Verificar que se cargaron
if not os.getenv('DB_PASSWORD'):
    print("‚ö†Ô∏è WARNING: DB_PASSWORD no est√° configurada en .env")
```

---

### 11. **Error: Circular Imports**

#### ‚ùå Problema Com√∫n
```python
# models/usuario.py
from config.database import db
from services.gestor_usuarios import GestorUsuarios  # ‚ùå

class Usuario(db.Model):
    def calcular_nivel(self):
        return GestorUsuarios.calcular_nivel(self)  # ‚ùå Import circular

# services/gestor_usuarios.py
from models.usuario import Usuario  # ‚ùå Importa Usuario

class GestorUsuarios:
    @staticmethod
    def calcular_nivel(usuario: Usuario):  # ‚ùå Usa Usuario
        pass
```

#### ‚úÖ Soluci√≥n Correcta
```python
# models/usuario.py - Solo definici√≥n del modelo
from config.database import db

class Usuario(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100))
    # NO incluir l√≥gica de negocio aqu√≠

# services/gestor_usuarios.py - Toda la l√≥gica aqu√≠
from models.usuario import Usuario  # ‚úÖ Import unidireccional

class GestorUsuarios:
    @staticmethod
    def calcular_nivel(usuario: Usuario):
        # L√≥gica de negocio
        return usuario.puntos // 100
```

---

### 12. **Error: No Cerrar Conexiones de Base de Datos**

#### ‚ùå Problema Com√∫n
```python
# services/gestor_usuarios.py
def obtener_usuarios():
    usuarios = Usuario.query.all()
    # ‚ùå No se cierra la sesi√≥n expl√≠citamente
    return [u.to_dict() for u in usuarios]
```

#### ‚úÖ Soluci√≥n Correcta
```python
# SQLAlchemy con Flask maneja esto autom√°ticamente
# Pero si haces consultas manuales:

from contextlib import contextmanager

@contextmanager
def session_scope():
    """Proporciona un scope transaccional para operaciones de BD"""
    session = db.session()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()

# Uso
def operacion_compleja():
    with session_scope() as session:
        usuario = Usuario(nombre="Test")
        session.add(usuario)
        # Se hace commit autom√°tico al salir del with
```

---

### 13. **Error: No Manejar Errores de Email**

#### ‚ùå Problema Com√∫n
```python
# services/correo_service.py
def enviar_verificacion(email, token):
    msg = Message(
        subject="Verificaci√≥n de cuenta",
        recipients=[email]
    )
    mail.send(msg)  # ‚ùå Si falla, crashea la app
```

#### ‚úÖ Soluci√≥n Correcta
```python
def enviar_verificacion(email, token):
    try:
        msg = Message(
            subject="Verificaci√≥n de cuenta",
            recipients=[email],
            body=f"Tu c√≥digo: {token}"
        )
        mail.send(msg)
        return True
    except Exception as e:
        print(f"‚ùå Error enviando email a {email}: {e}")
        # Registrar en logs
        logger.error(f"Fallo env√≠o email: {e}")
        return False

# En el servicio de registro
def registrar(data):
    usuario = crear_usuario(data)
    
    email_enviado = correo_service.enviar_verificacion(
        usuario.email, 
        usuario.token_verificacion
    )
    
    return {
        'success': True,
        'usuario_id': usuario.id,
        'email_enviado': email_enviado,
        'mensaje': 'Registro exitoso. Revisa tu email.' if email_enviado 
                   else 'Registro exitoso. Email no pudo enviarse.'
    }
```

---

### 14. **Error: Frontend - Dependencias Faltantes en useEffect**

#### ‚ùå Problema Com√∫n
```tsx
function UserProfile() {
  const [user, setUser] = useState(null);
  const userId = useParams().id;
  
  useEffect(() => {
    fetchUser(userId);  // ‚ùå userId no est√° en dependencias
  }, []);  // ‚ùå Array vac√≠o
  
  // Si userId cambia, no se vuelve a cargar
}
```

#### ‚úÖ Soluci√≥n Correcta
```tsx
function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const { id: userId } = useParams();
  
  useEffect(() => {
    async function loadUser() {
      setLoading(true);
      try {
        const response = await fetch(`/api/usuarios/${userId}`);
        const data = await response.json();
        setUser(data);
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    }
    
    if (userId) {
      loadUser();
    }
  }, [userId]);  // ‚úÖ userId como dependencia
  
  if (loading) return <Spinner />;
  
  return <div>{user?.nombre}</div>;
}
```

---

### 15. **Error: No Validar Roles/Permisos**

#### ‚ùå Problema Com√∫n
```python
# routes/admin/usuario_routes.py
@admin_bp.route('/usuarios/<int:usuario_id>/eliminar', methods=['DELETE'])
@jwt_required()
def eliminar_usuario(usuario_id):
    # ‚ùå Cualquier usuario autenticado puede eliminar
    gestor_usuarios.eliminar(usuario_id)
    return jsonify({'success': True})
```

#### ‚úÖ Soluci√≥n Correcta
```python
# utils/decorators.py
from functools import wraps
from flask_jwt_extended import get_jwt_identity
from flask import jsonify

def requiere_rol(rol_requerido):
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            usuario_id = get_jwt_identity()
            usuario = Usuario.query.get(usuario_id)
            
            if not usuario or usuario.rol != rol_requerido:
                return jsonify({
                    'error': 'No autorizado',
                    'mensaje': f'Se requiere rol: {rol_requerido}'
                }), 403
            
            return f(*args, **kwargs)
        return wrapper
    return decorator

# routes/admin/usuario_routes.py
from utils.decorators import requiere_rol

@admin_bp.route('/usuarios/<int:usuario_id>/eliminar', methods=['DELETE'])
@jwt_required()
@requiere_rol('admin')  # ‚úÖ Solo admins pueden eliminar
def eliminar_usuario(usuario_id):
    gestor_usuarios.eliminar(usuario_id)
    return jsonify({'success': True})
```

---

## üõ°Ô∏è Checklist de Seguridad

Antes de hacer commit, verifica:

- [ ] ‚úÖ No hay contrase√±as o tokens hardcodeados
- [ ] ‚úÖ Todas las rutas sensibles requieren autenticaci√≥n (`@jwt_required()`)
- [ ] ‚úÖ Se validan roles/permisos en rutas admin/profesor
- [ ] ‚úÖ Todas las entradas de usuario se validan (marshmallow)
- [ ] ‚úÖ Las contrase√±as se hashean con `bcrypt` o `werkzeug.security`
- [ ] ‚úÖ No se exponen datos sensibles en respuestas JSON
- [ ] ‚úÖ CORS configurado correctamente (no usar `*` en producci√≥n)
- [ ] ‚úÖ Variables de entorno en `.env` (no en el c√≥digo)
- [ ] ‚úÖ `.env` est√° en `.gitignore`

---

## üß™ Checklist de Testing

- [ ] ‚úÖ Probar con datos inv√°lidos (emails malformados, campos vac√≠os)
- [ ] ‚úÖ Probar con tokens expirados
- [ ] ‚úÖ Probar con usuarios sin permisos
- [ ] ‚úÖ Probar l√≠mites (strings muy largos, n√∫meros negativos)
- [ ] ‚úÖ Probar casos edge (usuario no existe, email duplicado)

---

## üìä Monitoreo y Debugging

### Logging Efectivo
```python
# config/logging.py
import logging

def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('app.log'),
            logging.StreamHandler()
        ]
    )

# En servicios
import logging
logger = logging.getLogger(__name__)

def registrar_usuario(data):
    logger.info(f"Intentando registrar usuario: {data['email']}")
    try:
        # ...
        logger.info(f"Usuario registrado exitosamente: {usuario.id}")
    except Exception as e:
        logger.error(f"Error registrando usuario: {e}", exc_info=True)
        raise
```

---

## üöÄ Performance

### Queries N+1
```python
# ‚ùå MAL - Query N+1
usuarios = Usuario.query.all()
for usuario in usuarios:
    print(usuario.perfil.biografia)  # ‚ùå Query por cada usuario

# ‚úÖ BIEN - Eager loading
from sqlalchemy.orm import joinedload

usuarios = Usuario.query.options(
    joinedload(Usuario.perfil)
).all()

for usuario in usuarios:
    print(usuario.perfil.biografia)  # ‚úÖ Una sola query
```

---

## üìù Documentaci√≥n

Documenta c√≥digo complejo:
```python
def calcular_nivel_usuario(progreso, tiempo_estudio, racha):
    """
    Calcula el nivel del usuario basado en m√∫ltiples factores.
    
    Args:
        progreso (int): Lecciones completadas (0-100)
        tiempo_estudio (int): Minutos totales estudiados
        racha (int): D√≠as consecutivos de estudio
    
    Returns:
        int: Nivel calculado (1-10)
    
    Examples:
        >>> calcular_nivel_usuario(50, 300, 7)
        5
    
    Notes:
        - El algoritmo prioriza la constancia (racha) sobre cantidad
        - Nivel m√°ximo es 10, independiente de los puntos
    """
    # Implementaci√≥n con comentarios explicativos
    pass
```

---

**Actualizado:** Octubre 2025  
**Basado en:** Errores reales del proyecto SpeakLexi  
**Versi√≥n:** 1.0.0