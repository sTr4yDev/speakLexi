# BACKEND COMPLETO - SpeakLexi
# Total archivos: 37
# Generado: 2025-10-28 22:57:30


================================================================================
# ARCHIVO: back-end/README.md
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/README.md
================================================================================




================================================================================
# ARCHIVO: back-end/app.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/app.py
================================================================================

# back-end/app.py
from flask import Flask, redirect
from flask_cors import CORS
from config.settings import Config
from config.database import init_db
from extensions import db, bcrypt, jwt, mail
from flask_jwt_extended import JWTManager
import logging
from logging.handlers import RotatingFileHandler
import os

# ========================================
# ‚≠ê IMPORTAR TODOS LOS MODELOS
# ========================================
# Importante: Importar ANTES de init_db() para que SQLAlchemy los registre
from models.usuario import Usuario, PerfilUsuario, PerfilEstudiante, PerfilProfesor, PerfilAdministrador
from models.leccion import Leccion, Actividad, leccion_multimedia
from models.multimedia import Multimedia, ConfiguracionMultimedia
from models.cursos import Curso, ProgresoCurso

# ========================================
# IMPORTAR BLUEPRINTS
# ========================================
from routes.auth import auth_bp
from routes.usuario_routes import usuario_bp
from routes.leccion_routes import leccion_bp
from routes.multimedia_routes import multimedia_bp
from routes.curso_routes import curso_bp
from routes.actividades_routes import actividades_bp


def create_app(config_class=Config):
    """Factory para crear la aplicaci√≥n Flask"""
    app = Flask(__name__)
    app.config.from_object(config_class)
    
    # FIX CR√çTICO: Deshabilitar trailing slash redirect
    app.url_map.strict_slashes = False
    
    # ========================================
    # CONFIGURACI√ìN CORS
    # ========================================
    CORS(app, resources={
        r"/api/*": {
            "origins": ["http://localhost:3000", "http://localhost:3001"],
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
            "allow_headers": ["Content-Type", "Authorization", "x-user-id"],
            "supports_credentials": True,
            "expose_headers": ["Content-Type", "Authorization"]
        }
    })
    
    # ========================================
    # INICIALIZAR EXTENSIONES
    # ========================================
    db.init_app(app)
    bcrypt.init_app(app)
    jwt.init_app(app)
    mail.init_app(app)

    # ========================================
    # CONFIGURAR JWT
    # ========================================
    @jwt.user_identity_loader
    def user_identity_lookup(identity):
        """Convierte cualquier identidad num√©rica en string para evitar errores con JWT"""
        return str(identity)

    @jwt.user_lookup_loader
    def user_lookup_callback(_jwt_header, jwt_data):
        """Cargar usuario desde JWT (opcional)"""
        identity = jwt_data["sub"]
        return Usuario.query.filter_by(id=int(identity)).one_or_none()

    # ========================================
    # LOGGING
    # ========================================
    if not app.debug:
        if not os.path.exists('logs'):
            os.mkdir('logs')
        
        file_handler = RotatingFileHandler(
            'logs/speaklexi.log',
            maxBytes=10240000,
            backupCount=10
        )
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
        ))
        file_handler.setLevel(logging.INFO)
        app.logger.addHandler(file_handler)
        app.logger.setLevel(logging.INFO)
        app.logger.info('SpeakLexi startup')
    
    # ========================================
    # BEFORE REQUEST FIXES
    # ========================================
    @app.before_request
    def handle_request_fixes():
        from flask import request
        
        # Remover trailing slash (excepto root)
        if request.path != '/' and request.path.endswith('/'):
            return redirect(request.path[:-1], code=308)
    
    # ========================================
    # REGISTRAR BLUEPRINTS
    # ========================================
    app.register_blueprint(auth_bp)
    app.register_blueprint(usuario_bp)
    app.register_blueprint(leccion_bp)
    app.register_blueprint(multimedia_bp)
    app.register_blueprint(curso_bp)
    app.register_blueprint(actividades_bp)
    
    # Log de rutas registradas (√∫til para debugging)
    if app.debug:
        print("\n" + "="*60)
        print("üìã RUTAS REGISTRADAS:")
        print("="*60)
        for rule in app.url_map.iter_rules():
            if rule.endpoint != 'static':
                methods = ','.join(sorted(rule.methods - {'HEAD', 'OPTIONS'}))
                print(f"{methods:20s} {rule}")
        print("="*60 + "\n")
    
    # ========================================
    # CREAR TABLAS Y DATOS INICIALES
    # ========================================
    with app.app_context():
        init_db()
    
    # ========================================
    # ENDPOINTS B√ÅSICOS
    # ========================================
    @app.route('/')
    def index():
        return {
            'mensaje': 'API SpeakLexi funcionando correctamente',
            'version': '3.0.0',
            'modulos': {
                'autenticacion': '‚úÖ',
                'usuarios': '‚úÖ',
                'cursos': '‚úÖ',
                'lecciones': '‚úÖ',
                'actividades': '‚úÖ',
                'multimedia': '‚úÖ',
                'progreso': '‚úÖ'
            },
            'endpoints': {
                'auth': '/api/auth',
                'usuarios': '/api/usuario',
                'cursos': '/api/cursos',
                'lecciones': '/api/lecciones',
                'actividades': '/api/actividades',
                'multimedia': '/api/multimedia'
            }
        }
    
    @app.route('/health')
    def health():
        """Endpoint de health check"""
        try:
            # Verificar conexi√≥n a BD
            db.session.execute(db.text('SELECT 1'))
            
            # Contar recursos
            total_usuarios = Usuario.query.count()
            total_cursos = Curso.query.count()
            total_lecciones = Leccion.query.count()
            total_actividades = Actividad.query.count()
            total_multimedia = Multimedia.query.count()
            
            return {
                'status': 'healthy',
                'database': 'connected',
                'version': '3.0.0',
                'recursos': {
                    'usuarios': total_usuarios,
                    'cursos': total_cursos,
                    'lecciones': total_lecciones,
                    'actividades': total_actividades,
                    'multimedia': total_multimedia
                }
            }
        except Exception as e:
            return {
                'status': 'unhealthy',
                'database': 'disconnected',
                'error': str(e)
            }, 503
    
    @app.errorhandler(404)
    def not_found(error):
        return {
            'success': False,
            'error': 'Endpoint no encontrado',
            'mensaje': str(error)
        }, 404
    
    @app.errorhandler(500)
    def internal_error(error):
        db.session.rollback()
        return {
            'success': False,
            'error': 'Error interno del servidor',
            'mensaje': str(error)
        }, 500
    
    return app


# ========================================
# CREAR LA APLICACI√ìN
# ========================================
app = create_app()

if __name__ == '__main__':
    print("\n" + "="*60)
    print("üöÄ INICIANDO SPEAKLEXI v3.0")
    print("="*60)
    print(f"üåê Servidor: http://localhost:5000")
    print(f"üìù Documentaci√≥n: http://localhost:5000/")
    print(f"üíö Health check: http://localhost:5000/health")
    print("="*60)
    print("üì¶ M√≥dulos Cargados:")
    print("   ‚úÖ Autenticaci√≥n (JWT)")
    print("   ‚úÖ Usuarios y Perfiles")
    print("   ‚úÖ Sistema de Cursos")
    print("   ‚úÖ Lecciones Din√°micas")
    print("   ‚úÖ Actividades Gamificadas")
    print("   ‚úÖ Multimedia")
    print("   ‚úÖ Seguimiento de Progreso")
    print("="*60 + "\n")
    
    app.run(
        host='0.0.0.0',
        port=5000,
        debug=True
    )


================================================================================
# ARCHIVO: back-end/config/__init__.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/__init__.py
================================================================================




================================================================================
# ARCHIVO: back-end/config/database.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/database.py
================================================================================

"""
Configuraci√≥n de la base de datos para SpeakLexi
Inicializa SQLAlchemy y proporciona utilidades para la DB
"""

import os
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

# Importar db desde extensions (instancia √∫nica)
from extensions import db


def init_db():
    """
    Crea todas las tablas y verifica la conexi√≥n
    IMPORTANTE: Se debe llamar DESPU√âS de db.init_app(app)
    """
    try:
        # Crear todas las tablas si no existen
        db.create_all()
        print("‚úÖ Tablas creadas correctamente en la base de datos")
        
        # Verificar conexi√≥n
        db.session.execute(db.text('SELECT 1'))
        print(f"‚úÖ Conexi√≥n exitosa a la base de datos: {os.getenv('DB_NAME', 'SpeakLexi')}")
        
    except Exception as e:
        print(f"‚ùå Error al conectar con la base de datos: {str(e)}")
        raise


def get_db():
    """
    Obtiene la instancia de la base de datos
    
    Returns:
        SQLAlchemy: Instancia de la base de datos
    """
    return db


# Configuraci√≥n de la base de datos desde variables de entorno
DATABASE_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': int(os.getenv('DB_PORT', 3306)),
    'user': os.getenv('DB_USER', 'root'),
    'password': os.getenv('DB_PASSWORD', ''),
    'database': os.getenv('DB_NAME', 'SpeakLexi'),
    'charset': 'utf8mb4',
    'collation': 'utf8mb4_unicode_ci'
}


def get_database_uri():
    """
    Genera la URI de conexi√≥n a la base de datos
    
    Returns:
        str: URI de conexi√≥n en formato SQLAlchemy
    """
    return (f"mysql+pymysql://{DATABASE_CONFIG['user']}:{DATABASE_CONFIG['password']}"
            f"@{DATABASE_CONFIG['host']}:{DATABASE_CONFIG['port']}/{DATABASE_CONFIG['database']}"
            f"?charset={DATABASE_CONFIG['charset']}")


def test_connection():
    """
    Prueba la conexi√≥n a la base de datos
    
    Returns:
        bool: True si la conexi√≥n es exitosa, False en caso contrario
    """
    try:
        from sqlalchemy import create_engine
        engine = create_engine(get_database_uri())
        connection = engine.connect()
        connection.close()
        print("‚úÖ Prueba de conexi√≥n exitosa")
        return True
    except Exception as e:
        print(f"‚ùå Error en prueba de conexi√≥n: {str(e)}")
        return False


================================================================================
# ARCHIVO: back-end/config/settings.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/settings.py
================================================================================

"""
Archivo de configuraci√≥n de la aplicaci√≥n SpeakLexi
Lee las variables de entorno desde el archivo .env
"""

import os
from dotenv import load_dotenv
from datetime import timedelta

# Cargar variables de entorno desde el archivo .env
load_dotenv()

# ==========================================================
# LEER VARIABLES DE ENTORNO (Se leen aqu√≠, pero se usan dentro de la clase Config)
# ==========================================================
DB_HOST = os.getenv('DB_HOST', 'localhost')
DB_PORT = os.getenv('DB_PORT', '3306')
DB_USER = os.getenv('DB_USER', 'root')
DB_PASSWORD = os.getenv('DB_PASSWORD', '') # Aseg√∫rate que tu .env tenga DB_PASSWORD
DB_NAME = os.getenv('DB_NAME', 'SpeakLexi')

SECRET_KEY_ENV = os.getenv('SECRET_KEY', 'clave_super_secreta_por_defecto')
DEBUG_ENV = os.getenv('DEBUG', 'True').lower() == 'true' # Convertir a booleano

JWT_SECRET_KEY_ENV = os.getenv('JWT_SECRET_KEY', SECRET_KEY_ENV) # Usa SECRET_KEY_ENV como fallback
JWT_ACCESS_TOKEN_EXPIRES_ENV = int(os.getenv('JWT_ACCESS_TOKEN_EXPIRES', 3600))

MAIL_SERVER_ENV = os.getenv('MAIL_SERVER', 'smtp.gmail.com')
MAIL_PORT_ENV = int(os.getenv('MAIL_PORT', 587))
MAIL_USE_TLS_ENV = os.getenv('MAIL_USE_TLS', 'True').lower() == 'true'
MAIL_USERNAME_ENV = os.getenv('MAIL_USERNAME')
MAIL_PASSWORD_ENV = os.getenv('MAIL_PASSWORD')
MAIL_DEFAULT_SENDER_ENV = os.getenv('MAIL_DEFAULT_SENDER')

UPLOAD_FOLDER_ENV = os.getenv('UPLOAD_FOLDER', 'uploads')
MAX_CONTENT_LENGTH_ENV = int(os.getenv('MAX_CONTENT_LENGTH', 16777216)) # 16MB
ALLOWED_EXTENSIONS_ENV = set(os.getenv('ALLOWED_EXTENSIONS', 'png,jpg,jpeg,gif,mp3,mp4,pdf').split(','))

CORS_ORIGINS_ENV = os.getenv('CORS_ORIGINS', 'http://localhost:3000').split(',')

# ==========================================================
# CLASE CONFIG PARA FLASK
# ==========================================================
class Config:
    """Clase de configuraci√≥n para Flask"""

    # --- CORRECCI√ìN: Construir URI dentro de la clase ---
    # Base de datos
    SQLALCHEMY_DATABASE_URI = f"mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    # --- FIN CORRECCI√ìN ---

    # Aplicaci√≥n
    SECRET_KEY = SECRET_KEY_ENV
    DEBUG = DEBUG_ENV

    # JWT
    JWT_SECRET_KEY = JWT_SECRET_KEY_ENV
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(seconds=JWT_ACCESS_TOKEN_EXPIRES_ENV)
    # Configuraci√≥n CSRF (deshabilitado como antes)
    JWT_CSRF_CHECK_FORM = False
    JWT_CSRF_IN_COOKIES = False
    JWT_CSRF_METHODS = [] 

    # Correo
    MAIL_SERVER = MAIL_SERVER_ENV
    MAIL_PORT = MAIL_PORT_ENV
    MAIL_USE_TLS = MAIL_USE_TLS_ENV
    MAIL_USERNAME = MAIL_USERNAME_ENV
    MAIL_PASSWORD = MAIL_PASSWORD_ENV
    # Ajuste para MAIL_DEFAULT_SENDER si viene del .env o se construye
    if MAIL_DEFAULT_SENDER_ENV:
         MAIL_DEFAULT_SENDER = MAIL_DEFAULT_SENDER_ENV
    else:
         mail_sender_name = "SpeakLexi"
         mail_sender_email = MAIL_USERNAME_ENV or 'noreply@speaklexi.com'
         MAIL_DEFAULT_SENDER = (mail_sender_name, mail_sender_email)

    # Archivos
    UPLOAD_FOLDER = UPLOAD_FOLDER_ENV
    MAX_CONTENT_LENGTH = MAX_CONTENT_LENGTH_ENV
    ALLOWED_EXTENSIONS = ALLOWED_EXTENSIONS_ENV

    # CORS (Aunque flask_cors lo maneja en app.py, lo mantenemos aqu√≠ por consistencia)
    CORS_ORIGINS = CORS_ORIGINS_ENV


# ==========================================================
# IMPRIMIR CONFIGURACI√ìN AL INICIAR (Solo en desarrollo)
# ==========================================================
# Usar la variable DEBUG_ENV le√≠da directamente del entorno
if DEBUG_ENV:
    # A√±adimos un print para confirmar la URI que se est√° usando
    print("\n" + "="*60)
    print("‚öôÔ∏è  CONFIGURACI√ìN DE SPEAKLEXI (Le√≠da desde .env)")
    print("="*60)
    print(f"üî© Debug Mode: {DEBUG_ENV}")
    print(f"üîë Secret Key: {'*' * len(SECRET_KEY_ENV) if SECRET_KEY_ENV else 'No definida'}")
    print(f"üîë JWT Secret Key: {'*' * len(JWT_SECRET_KEY_ENV) if JWT_SECRET_KEY_ENV else 'Usando SECRET_KEY'}")
    print(f"‚è≥ JWT Expiraci√≥n: {JWT_ACCESS_TOKEN_EXPIRES_ENV} segundos")
    print("-" * 60)
    print(f"üóÑÔ∏è  Base de datos: {DB_NAME}")
    print(f"üîó Host: {DB_HOST}:{DB_PORT}")
    print(f"üë§ Usuario DB: {DB_USER}")
    # ¬°Importante! No imprimir la contrase√±a de la BD en producci√≥n
    print(f"üîí Password DB: {'S√≠' if DB_PASSWORD else 'No'}") 
    # Imprimir la URI construida para depuraci√≥n
    print(f"URI Construida: mysql+pymysql://{DB_USER}:{'****' if DB_PASSWORD else ''}@{DB_HOST}:{DB_PORT}/{DB_NAME}")
    print("-" * 60)
    print(f"üìß Correo: {MAIL_USERNAME_ENV or 'No definido'}")
    print(f"‚úâÔ∏è Remitente: {Config.MAIL_DEFAULT_SENDER}") # Usar el valor final de la clase Config
    print("-" * 60)
    print(f"üåê Or√≠genes CORS Permitidos: {', '.join(CORS_ORIGINS_ENV)}")
    print("="*60 + "\n")

    # A√±adir el print que ten√≠as para la clave JWT cargada
    print(f"üîë JWT Secret Key cargada en Config: '{Config.JWT_SECRET_KEY}'") 




================================================================================
# ARCHIVO: back-end/extensions.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/extensions.py
================================================================================

"""
Extensiones de Flask - SpeakLexi
Inicializaci√≥n centralizada de todas las extensiones
"""

from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager
from flask_mail import Mail

# Inicializar extensiones sin app (se vinculan despu√©s con init_app)
db = SQLAlchemy()
bcrypt = Bcrypt()
jwt = JWTManager()
mail = Mail()


================================================================================
# ARCHIVO: back-end/models/cursos.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/cursos.py
================================================================================

# back-end/models/cursos.py
from extensions import db
from sqlalchemy.dialects.mysql import JSON
from datetime import datetime, date
from decimal import Decimal


class Curso(db.Model):
    """Modelo para cursos organizados por niveles CEFR (A1-C2)"""
    __tablename__ = 'cursos'
    
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    nivel = db.Column(db.String(10), nullable=False)  # A1, A2, B1, B2, C1, C2
    descripcion = db.Column(db.Text)
    idioma = db.Column(db.String(50), nullable=False, default='ingles')
    codigo = db.Column(db.String(20), unique=True, nullable=False)
    profesor_id = db.Column(db.Integer, db.ForeignKey('usuarios.id'))
    imagen_portada = db.Column(db.String(500))
    orden = db.Column(db.Integer, default=0)
    activo = db.Column(db.Boolean, default=True)
    total_lecciones = db.Column(db.Integer, default=0)
    duracion_estimada_total = db.Column(db.Integer, default=0)
    requisitos_previos = db.Column(JSON)
    objetivos_aprendizaje = db.Column(JSON)
    creado_en = db.Column(db.DateTime, default=datetime.utcnow)
    actualizado_en = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relaciones
    lecciones = db.relationship('Leccion', backref='curso', lazy='dynamic')
    progresos = db.relationship('ProgresoCurso', backref='curso', lazy='dynamic')
    profesor = db.relationship('Usuario', foreign_keys=[profesor_id], backref='cursos_impartidos')
    
    def to_dict(self, incluir_lecciones=False, incluir_profesor=False):
        """Convierte el curso a diccionario"""
        data = {
            'id': self.id,
            'nombre': self.nombre,
            'nivel': self.nivel,
            'descripcion': self.descripcion,
            'idioma': self.idioma,
            'codigo': self.codigo,
            'profesor_id': self.profesor_id,
            'imagen_portada': self.imagen_portada,
            'orden': self.orden,
            'activo': self.activo,
            'total_lecciones': self.total_lecciones,
            'duracion_estimada_total': self.duracion_estimada_total,
            'requisitos_previos': self.requisitos_previos or [],
            'objetivos_aprendizaje': self.objetivos_aprendizaje or [],
            'creado_en': self.creado_en.isoformat() if self.creado_en else None,
            'actualizado_en': self.actualizado_en.isoformat() if self.actualizado_en else None
        }
        
        if incluir_profesor and self.profesor:
            data['profesor'] = {
                'id': self.profesor.id,
                'nombre': self.profesor.nombre,
                'primer_apellido': self.profesor.primer_apellido,
                'correo': self.profesor.correo
            }
        
        if incluir_lecciones:
            from models.leccion import Leccion
            lecciones = Leccion.query.filter_by(curso_id=self.id).order_by(Leccion.orden).all()
            data['lecciones'] = [l.to_dict() for l in lecciones]
        
        return data
    
    def tiene_prerequisitos_cumplidos(self, usuario_id):
        """Verifica si el usuario cumple con los prerequisitos"""
        if not self.requisitos_previos:
            return True
        
        from models.cursos import ProgresoCurso
        for curso_prereq_id in self.requisitos_previos:
            progreso = ProgresoCurso.query.filter_by(
                usuario_id=usuario_id,
                curso_id=curso_prereq_id,
                estado='completado'
            ).first()
            
            if not progreso:
                return False
        
        return True
    
    def __repr__(self):
        return f'<Curso {self.codigo}: {self.nombre}>'


class ProgresoCurso(db.Model):
    """Modelo para seguimiento del progreso de los usuarios en los cursos"""
    __tablename__ = 'progreso_cursos'
    
    id = db.Column(db.Integer, primary_key=True)
    usuario_id = db.Column(db.Integer, db.ForeignKey('usuarios.id'), nullable=False)
    curso_id = db.Column(db.Integer, db.ForeignKey('cursos.id'), nullable=False)
    lecciones_completadas = db.Column(db.Integer, default=0)
    lecciones_totales = db.Column(db.Integer, default=0)
    porcentaje_completado = db.Column(db.Numeric(5, 2), default=0.00)
    fecha_inicio = db.Column(db.Date)
    fecha_completado = db.Column(db.Date)
    estado = db.Column(
        db.Enum('no_iniciado', 'en_progreso', 'completado', 'abandonado'),
        default='no_iniciado'
    )
    tiempo_dedicado = db.Column(db.Integer, default=0)  # en minutos
    puntuacion_promedio = db.Column(db.Numeric(5, 2))
    ultima_leccion_id = db.Column(db.Integer, db.ForeignKey('lecciones.id'))
    
    # Relaciones
    usuario = db.relationship('Usuario', backref='progresos_cursos')
    ultima_leccion = db.relationship('Leccion', foreign_keys=[ultima_leccion_id])
    
    __table_args__ = (
        db.UniqueConstraint('usuario_id', 'curso_id', name='unique_usuario_curso'),
    )
    
    def to_dict(self, incluir_curso=False, incluir_usuario=False):
        """Convierte el progreso a diccionario"""
        data = {
            'id': self.id,
            'usuario_id': self.usuario_id,
            'curso_id': self.curso_id,
            'lecciones_completadas': self.lecciones_completadas,
            'lecciones_totales': self.lecciones_totales,
            'porcentaje_completado': float(self.porcentaje_completado) if self.porcentaje_completado else 0.0,
            'fecha_inicio': self.fecha_inicio.isoformat() if self.fecha_inicio else None,
            'fecha_completado': self.fecha_completado.isoformat() if self.fecha_completado else None,
            'estado': self.estado,
            'tiempo_dedicado': self.tiempo_dedicado,
            'puntuacion_promedio': float(self.puntuacion_promedio) if self.puntuacion_promedio else None,
            'ultima_leccion_id': self.ultima_leccion_id
        }
        
        if incluir_curso and self.curso:
            data['curso'] = self.curso.to_dict()
        
        if incluir_usuario and self.usuario:
            data['usuario'] = {
                'id': self.usuario.id,
                'nombre': self.usuario.nombre,
                'primer_apellido': self.usuario.primer_apellido,
                'correo': self.usuario.correo
            }
        
        return data
    
    def actualizar_progreso(self):
        """Actualiza el porcentaje de completado"""
        if self.lecciones_totales > 0:
            self.porcentaje_completado = Decimal(
                round((self.lecciones_completadas / self.lecciones_totales) * 100, 2)
            )
            
            if self.porcentaje_completado >= 100 and self.estado != 'completado':
                self.estado = 'completado'
                if not self.fecha_completado:
                    self.fecha_completado = date.today()
    
    def __repr__(self):
        return f'<ProgresoCurso Usuario:{self.usuario_id} Curso:{self.curso_id} {self.porcentaje_completado}%>'



================================================================================
# ARCHIVO: back-end/models/leccion.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/leccion.py
================================================================================

# back-end/models/leccion.py
from __future__ import annotations
from datetime import datetime
from typing import Any, Dict, List, Optional

from config.database import db
from sqlalchemy import Enum as SQLEnum
import enum


# -------------------- Mixins --------------------
class TimestampMixin:
    """Mixin para columnas de auditor√≠a comunes."""
    creado_en = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    actualizado_en = db.Column(
        db.DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )


class SerializableMixin:
    """Mixin simple para exponer to_dict (puede ser sobreescrito)."""
    def to_dict_base(self) -> Dict[str, Any]:
        return {}


# -------------------- Enums --------------------
class NivelDificultad(enum.Enum):
    """Enum para niveles de dificultad de lecciones"""
    PRINCIPIANTE = "principiante"
    INTERMEDIO = "intermedio"
    AVANZADO = "avanzado"


class TipoActividad(enum.Enum):
    """Enum para tipos de actividades disponibles"""
    MULTIPLE_CHOICE = "multiple_choice"
    FILL_BLANK = "fill_blank"
    MATCHING = "matching"
    TRANSLATION = "translation"
    LISTEN_REPEAT = "listen_repeat"
    TRUE_FALSE = "true_false"
    WORD_ORDER = "word_order"


class EstadoLeccion(enum.Enum):
    """Enum para estados de publicaci√≥n de lecciones"""
    BORRADOR = "borrador"
    PUBLICADA = "publicada"
    ARCHIVADA = "archivada"


# -------------------- Models: Leccion + Actividad --------------------
class Leccion(db.Model, TimestampMixin, SerializableMixin):
    """
    Modelo para almacenar lecciones del sistema.
    """
    __tablename__ = 'lecciones'

    # Identificaci√≥n
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    
    # ‚≠ê AGREGAR: Foreign Key al curso
    curso_id = db.Column(db.Integer, db.ForeignKey('cursos.id'), nullable=True, index=True)
    
    titulo = db.Column(db.String(200), nullable=False, index=True)
    descripcion = db.Column(db.Text)

    # Contenido
    contenido = db.Column(db.JSON, nullable=False, default=dict)

    # Clasificaci√≥n
    nivel = db.Column(
        SQLEnum(
            NivelDificultad,
            values_callable=lambda x: [e.value for e in x],
            native_enum=False
        ),
        nullable=False,
        index=True,
        default=NivelDificultad.PRINCIPIANTE
    )
    idioma = db.Column(db.String(50), nullable=False, index=True, default='ingles')
    categoria = db.Column(db.String(100), index=True)
    etiquetas = db.Column(db.JSON, default=list)

    # Orden y estructura
    orden = db.Column(db.Integer, index=True)
    requisitos = db.Column(db.JSON, default=list)

    # Metadata de aprendizaje
    duracion_estimada = db.Column(db.Integer, default=10)
    puntos_xp = db.Column(db.Integer, default=50, nullable=False)

    # Estado
    estado = db.Column(
        SQLEnum(
            EstadoLeccion,
            values_callable=lambda x: [e.value for e in x],
            native_enum=False
        ),
        nullable=False,
        default=EstadoLeccion.BORRADOR,
        index=True
    )

    # Auditor√≠a
    creado_por = db.Column(db.Integer, db.ForeignKey('usuarios.id'), nullable=False)

    # Relaciones
    actividades = db.relationship(
        'Actividad',
        backref='leccion',
        lazy='select',
        cascade='all, delete-orphan',
        order_by='Actividad.orden'
    )

    recursos_multimedia = db.relationship(
        'Multimedia',
        secondary='leccion_multimedia',
        backref=db.backref('lecciones', lazy='select')
    )

    creador = db.relationship('Usuario', foreign_keys=[creado_por])
    
    # ‚≠ê NO definir relaci√≥n de vuelta con Curso aqu√≠, ya est√° en Curso.lecciones

    # √çndices compuestos
    __table_args__ = (
        db.Index('idx_leccion_nivel_idioma', 'nivel', 'idioma'),
        db.Index('idx_leccion_estado_orden', 'estado', 'orden'),
        db.Index('idx_leccion_curso_orden', 'curso_id', 'orden'),
    )

    def __repr__(self) -> str:
        return f'<Leccion {self.id}: {self.titulo}>'

    # -------------------- Serializaci√≥n --------------------
    def to_dict(self, incluir_actividades: bool = False, incluir_multimedia: bool = False) -> Dict[str, Any]:
        data: Dict[str, Any] = {
            'id': self.id,
            'curso_id': self.curso_id,  # ‚≠ê Incluir curso_id
            'titulo': self.titulo,
            'descripcion': self.descripcion,
            'contenido': self.contenido,
            'nivel': self.nivel.value if isinstance(self.nivel, NivelDificultad) else self.nivel,
            'idioma': self.idioma,
            'categoria': self.categoria,
            'etiquetas': self.etiquetas or [],
            'orden': self.orden,
            'requisitos': self.requisitos or [],
            'duracion_estimada': self.duracion_estimada,
            'puntos_xp': self.puntos_xp,
            'estado': self.estado.value if isinstance(self.estado, EstadoLeccion) else self.estado,
            'creado_por': self.creado_por,
            'creado_en': self.creado_en.isoformat() if getattr(self, 'creado_en', None) else None,
            'actualizado_en': self.actualizado_en.isoformat() if getattr(self, 'actualizado_en', None) else None,
        }

        if incluir_actividades:
            data['actividades'] = [actividad.to_dict() for actividad in list(self.actividades)]

        if incluir_multimedia:
            data['multimedia'] = [recurso.to_dict() for recurso in self.recursos_multimedia]

        return data

    # -------------------- Utilidades --------------------
    @classmethod
    def get_by_id(cls, _id: int) -> Optional['Leccion']:
        return cls.query.get(_id)

    @classmethod
    def search(cls, q: str, limit: int = 20) -> List['Leccion']:
        """B√∫squeda simple por t√≠tulo y descripci√≥n (case-insensitive)."""
        like_q = f"%{q}%"
        return (
            cls.query.filter(
                db.or_(cls.titulo.ilike(like_q), cls.descripcion.ilike(like_q))
            )
            .order_by(cls.orden)
            .limit(limit)
            .all()
        )

    @classmethod
    def paginate(cls, page: int = 1, per_page: int = 20):
        return cls.query.order_by(cls.orden).paginate(page=page, per_page=per_page, error_out=False)

    def validar_requisitos_cumplidos(self, lecciones_completadas: List[int]) -> bool:
        if not self.requisitos:
            return True
        return all(req_id in lecciones_completadas for req_id in (self.requisitos or []))

    def publicar(self) -> None:
        if self.estado == EstadoLeccion.BORRADOR:
            self.estado = EstadoLeccion.PUBLICADA
            self.actualizado_en = datetime.utcnow()

    def archivar(self) -> None:
        self.estado = EstadoLeccion.ARCHIVADA
        self.actualizado_en = datetime.utcnow()


class Actividad(db.Model, TimestampMixin, SerializableMixin):
    """
    Modelo para actividades dentro de las lecciones.
    """
    __tablename__ = 'actividades'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    leccion_id = db.Column(
        db.Integer,
        db.ForeignKey('lecciones.id', ondelete='CASCADE'),
        nullable=False,
        index=True
    )

    # Tipo y contenido
    tipo = db.Column(
        SQLEnum(
            TipoActividad,
            values_callable=lambda x: [e.value for e in x],
            native_enum=False
        ),
        nullable=False
    )
    pregunta = db.Column(db.Text, nullable=False)
    instrucciones = db.Column(db.Text)

    # Opciones y respuestas
    opciones = db.Column(db.JSON, default=dict)
    respuesta_correcta = db.Column(db.JSON, nullable=False)

    # Retroalimentaci√≥n
    retroalimentacion = db.Column(db.JSON, default=dict)
    pista = db.Column(db.Text)

    # Metadata
    puntos = db.Column(db.Integer, default=10, nullable=False)
    orden = db.Column(db.Integer, nullable=False)
    tiempo_limite = db.Column(db.Integer)

    # Multimedia asociado
    multimedia_id = db.Column(db.Integer, db.ForeignKey('multimedia.id'))

    __table_args__ = (
        db.Index('idx_actividad_leccion_orden', 'leccion_id', 'orden'),
    )

    def __repr__(self) -> str:
        tipo_val = self.tipo.value if isinstance(self.tipo, TipoActividad) else self.tipo
        return f'<Actividad {self.id} - {tipo_val}>'

    def to_dict(self, incluir_respuesta: bool = False) -> Dict[str, Any]:
        data: Dict[str, Any] = {
            'id': self.id,
            'leccion_id': self.leccion_id,
            'tipo': self.tipo.value if isinstance(self.tipo, TipoActividad) else self.tipo,
            'pregunta': self.pregunta,
            'instrucciones': self.instrucciones,
            'opciones': self.opciones,
            'retroalimentacion': self.retroalimentacion,
            'pista': self.pista,
            'puntos': self.puntos,
            'orden': self.orden,
            'tiempo_limite': self.tiempo_limite,
            'multimedia_id': self.multimedia_id,
            'creado_en': self.creado_en.isoformat() if getattr(self, 'creado_en', None) else None,
            'actualizado_en': self.actualizado_en.isoformat() if getattr(self, 'actualizado_en', None) else None,
        }

        if incluir_respuesta:
            data['respuesta_correcta'] = self.respuesta_correcta

        return data

    def verificar_respuesta(self, respuesta_usuario: Any) -> Dict[str, Any]:
        correcta = self._comparar_respuesta(respuesta_usuario)
        retro = self.retroalimentacion.get('correcta' if correcta else 'incorrecta')
        return {
            'correcta': correcta,
            'retroalimentacion': retro or ('Respuesta correcta' if correcta else 'Respuesta incorrecta'),
            'puntos': self.puntos if correcta else 0
        }

    def _comparar_respuesta(self, respuesta_usuario: Any) -> bool:
        """Compara respuesta del usuario con la correcta seg√∫n el tipo."""
        def _norm(x: Any) -> Any:
            if x is None:
                return x
            if isinstance(x, str):
                return x.strip().lower()
            return x

        if self.tipo == TipoActividad.MULTIPLE_CHOICE:
            return _norm(str(respuesta_usuario)) == _norm(str(self.respuesta_correcta))

        if self.tipo == TipoActividad.TRUE_FALSE:
            return bool(respuesta_usuario) == bool(self.respuesta_correcta)

        if self.tipo == TipoActividad.FILL_BLANK:
            return _norm(str(respuesta_usuario)) == _norm(str(self.respuesta_correcta))

        if self.tipo == TipoActividad.MATCHING:
            return respuesta_usuario == self.respuesta_correcta

        if self.tipo == TipoActividad.WORD_ORDER:
            return respuesta_usuario == self.respuesta_correcta

        if self.tipo == TipoActividad.TRANSLATION:
            return _norm(str(respuesta_usuario)) == _norm(str(self.respuesta_correcta))

        return respuesta_usuario == self.respuesta_correcta


# Tabla de asociaci√≥n para relaci√≥n muchos-a-muchos
leccion_multimedia = db.Table(
    'leccion_multimedia',
    db.Column('leccion_id', db.Integer, db.ForeignKey('lecciones.id', ondelete='CASCADE'), primary_key=True),
    db.Column('multimedia_id', db.Integer, db.ForeignKey('multimedia.id', ondelete='CASCADE'), primary_key=True),
    db.Column('orden', db.Integer, default=0),
    db.Column('creado_en', db.DateTime, default=datetime.utcnow)
)


================================================================================
# ARCHIVO: back-end/models/multimedia.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/multimedia.py
================================================================================

# multimedia.py
from __future__ import annotations
from datetime import datetime
from typing import Any, Dict, Optional

from config.database import db
from sqlalchemy import Enum as SQLEnum
import enum


class TipoMultimedia(enum.Enum):
    """Enum para tipos de recursos multimedia"""
    IMAGEN = "imagen"
    AUDIO = "audio"
    VIDEO = "video"
    DOCUMENTO = "documento"


class EstadoMultimedia(enum.Enum):
    """Enum para estados de procesamiento de multimedia"""
    PENDIENTE = "pendiente"
    PROCESANDO = "procesando"
    DISPONIBLE = "disponible"
    ERROR = "error"


class Multimedia(db.Model):
    """
    Modelo para almacenar recursos multimedia del sistema.
    """
    __tablename__ = 'multimedia'

    # Identificaci√≥n
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    nombre_archivo = db.Column(db.String(255), nullable=False)
    nombre_almacenado = db.Column(db.String(255), unique=True, nullable=False, index=True)

    # Tipo y clasificaci√≥n
    tipo = db.Column(SQLEnum(TipoMultimedia), nullable=False, index=True)
    mime_type = db.Column(db.String(100), nullable=False)
    categoria = db.Column(db.String(50), index=True)  # vocabulario, gramatica, pronunciacion, etc.

    # URLs y almacenamiento
    url = db.Column(db.String(500), nullable=False)
    url_thumbnail = db.Column(db.String(500))
    ruta_local = db.Column(db.String(500))  # Ruta en el servidor si aplica

    # Propiedades del archivo
    tamano = db.Column(db.Integer)  # En bytes
    duracion = db.Column(db.Integer)  # En segundos (para audio/video)
    dimensiones = db.Column(db.JSON)  # {"ancho": 1920, "alto": 1080}

    # Estado y procesamiento
    estado = db.Column(
        SQLEnum(EstadoMultimedia),
        nullable=False,
        default=EstadoMultimedia.PENDIENTE,
        index=True
    )
    mensaje_error = db.Column(db.Text)  # Si estado es ERROR

    # Informaci√≥n adicional
    descripcion = db.Column(db.Text)
    alt_text = db.Column(db.String(200))  # Para accesibilidad
    transcripcion = db.Column(db.Text)  # Para audio/video
    etiquetas = db.Column(db.JSON, default=list)

    # Usar meta_data en Python, columna 'meta' en DB (metadata es reservado)
    meta_data = db.Column('meta', db.JSON, default=dict)

    # Uso y estad√≠sticas
    veces_usado = db.Column(db.Integer, default=0)
    ultima_vez_usado = db.Column(db.DateTime)

    # Auditor√≠a
    subido_por = db.Column(db.Integer, db.ForeignKey('usuarios.id'), nullable=False)
    creado_en = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    actualizado_en = db.Column(
        db.DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False
    )

    # Relaciones
    subidor = db.relationship('Usuario', foreign_keys=[subido_por])

    # √çndices compuestos
    __table_args__ = (
        db.Index('idx_multimedia_tipo_estado', 'tipo', 'estado'),
        db.Index('idx_multimedia_categoria', 'categoria'),
    )

    def __repr__(self) -> str:
        return f'<Multimedia {self.id}: {self.nombre_archivo}>'

    def to_dict(self, incluir_metadata: bool = False) -> Dict[str, Any]:
        data: Dict[str, Any] = {
            'id': self.id,
            'nombre_archivo': self.nombre_archivo,
            'tipo': self.tipo.value if isinstance(self.tipo, TipoMultimedia) else self.tipo,
            'mime_type': self.mime_type,
            'categoria': self.categoria,
            'url': self.url,
            'url_thumbnail': self.url_thumbnail,
            'tamano': self.tamano,
            'tamano_formateado': self._formatear_tamano(),
            'duracion': self.duracion,
            'duracion_formateada': self._formatear_duracion(),
            'dimensiones': self.dimensiones,
            'estado': self.estado.value if isinstance(self.estado, EstadoMultimedia) else self.estado,
            'descripcion': self.descripcion,
            'alt_text': self.alt_text,
            'transcripcion': self.transcripcion,
            'etiquetas': self.etiquetas or [],
            'veces_usado': self.veces_usado,
            'subido_por': self.subido_por,
            'creado_en': self.creado_en.isoformat() if getattr(self, 'creado_en', None) else None,
            'actualizado_en': self.actualizado_en.isoformat() if getattr(self, 'actualizado_en', None) else None,
        }

        if incluir_metadata:
            data['metadata'] = self.meta_data or {}
            data['nombre_almacenado'] = self.nombre_almacenado
            data['ruta_local'] = self.ruta_local
            data['mensaje_error'] = self.mensaje_error

        return data

    def _formatear_tamano(self) -> str:
        """Formatea el tama√±o sin mutar self.tamano."""
        if self.tamano is None:
            return "Desconocido"
        tam = float(self.tamano)
        unidades = ['B', 'KB', 'MB', 'GB', 'TB']
        idx = 0
        while tam >= 1024.0 and idx < len(unidades) - 1:
            tam /= 1024.0
            idx += 1
        return f"{tam:.2f} {unidades[idx]}"

    def _formatear_duracion(self) -> Optional[str]:
        if self.duracion is None:
            return None
        segundos_total = int(self.duracion)
        horas = segundos_total // 3600
        minutos = (segundos_total % 3600) // 60
        segundos = segundos_total % 60
        if horas > 0:
            return f"{horas}:{minutos:02d}:{segundos:02d}"
        return f"{minutos}:{segundos:02d}"

    def marcar_disponible(self) -> None:
        self.estado = EstadoMultimedia.DISPONIBLE
        self.actualizado_en = datetime.utcnow()

    def marcar_error(self, mensaje_error: str) -> None:
        self.estado = EstadoMultimedia.ERROR
        self.mensaje_error = mensaje_error
        self.actualizado_en = datetime.utcnow()

    def incrementar_uso(self) -> None:
        self.veces_usado = (self.veces_usado or 0) + 1
        self.ultima_vez_usado = datetime.utcnow()

    def es_imagen(self) -> bool:
        return self.tipo == TipoMultimedia.IMAGEN

    def es_audio(self) -> bool:
        return self.tipo == TipoMultimedia.AUDIO

    def es_video(self) -> bool:
        return self.tipo == TipoMultimedia.VIDEO

    def puede_tener_thumbnail(self) -> bool:
        return self.tipo in [TipoMultimedia.IMAGEN, TipoMultimedia.VIDEO]

    @staticmethod
    def generar_nombre_unico(nombre_original: str) -> str:
        import uuid
        from pathlib import Path
        extension = Path(nombre_original).suffix
        return f"{uuid.uuid4().hex}{extension}"

    @staticmethod
    def validar_tipo_archivo(mime_type: str, tipo_esperado: TipoMultimedia) -> bool:
        tipos_validos = {
            TipoMultimedia.IMAGEN: [
                'image/jpeg', 'image/jpg', 'image/png', 'image/gif',
                'image/webp', 'image/svg+xml'
            ],
            TipoMultimedia.AUDIO: [
                'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg',
                'audio/webm', 'audio/aac'
            ],
            TipoMultimedia.VIDEO: [
                'video/mp4', 'video/webm', 'video/ogg', 'video/quicktime'
            ],
            TipoMultimedia.DOCUMENTO: [
                'application/pdf', 'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'text/plain'
            ]
        }
        return mime_type in tipos_validos.get(tipo_esperado, [])

    @staticmethod
    def obtener_extension_mime(mime_type: str) -> str:
        extensiones = {
            'image/jpeg': '.jpg',
            'image/jpg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.webp',
            'audio/mpeg': '.mp3',
            'audio/mp3': '.mp3',
            'audio/wav': '.wav',
            'audio/ogg': '.ogg',
            'video/mp4': '.mp4',
            'video/webm': '.webm',
            'application/pdf': '.pdf',
            'text/plain': '.txt'
        }
        return extensiones.get(mime_type, '.bin')


class ConfiguracionMultimedia(db.Model):
    """
    Modelo para configuraci√≥n global de multimedia.
    """
    __tablename__ = 'configuracion_multimedia'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    clave = db.Column(db.String(100), unique=True, nullable=False, index=True)
    valor = db.Column(db.Text, nullable=False)
    descripcion = db.Column(db.Text)
    actualizado_en = db.Column(
        db.DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )

    @staticmethod
    def obtener_valor(clave: str, valor_por_defecto: Optional[Any] = None) -> Any:
        config = ConfiguracionMultimedia.query.filter_by(clave=clave).first()
        return config.valor if config else valor_por_defecto

    @staticmethod
    def establecer_valor(clave: str, valor: Any, descripcion: Optional[str] = None) -> 'ConfiguracionMultimedia':
        config = ConfiguracionMultimedia.query.filter_by(clave=clave).first()
        if config:
            config.valor = str(valor)
            config.actualizado_en = datetime.utcnow()
        else:
            config = ConfiguracionMultimedia(clave=clave, valor=str(valor), descripcion=descripcion)
            db.session.add(config)
        db.session.commit()
        return config

    def __repr__(self) -> str:
        return f'<ConfigMultimedia {self.clave}: {self.valor}>'


# Valores por defecto de configuraci√≥n
CONFIGURACION_POR_DEFECTO = {
    'max_tamano_imagen': '5242880',  # 5 MB en bytes
    'max_tamano_audio': '10485760',  # 10 MB
    'max_tamano_video': '52428800',  # 50 MB
    'max_tamano_documento': '10485760',  # 10 MB
    'ruta_almacenamiento': 'uploads/multimedia',
    'generar_thumbnails': 'true',
    'thumbnail_ancho': '300',
    'thumbnail_alto': '300',
    'calidad_compresion_imagen': '85',
    'formatos_permitidos_imagen': 'jpg,jpeg,png,gif,webp',
    'formatos_permitidos_audio': 'mp3,wav,ogg',
    'formatos_permitidos_video': 'mp4,webm',
    'formatos_permitidos_documento': 'pdf,txt'
}


================================================================================
# ARCHIVO: back-end/models/usuario.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/usuario.py
================================================================================

from config.database import db
from werkzeug.security import generate_password_hash, check_password_hash 
from datetime import datetime
from sqlalchemy import Date, JSON, Numeric

# ============================================================
# MODELO USUARIO (SIN CAMBIOS)
# ============================================================

class Usuario(db.Model):
    __tablename__ = "usuarios"

    id = db.Column(db.Integer, primary_key=True)
    id_publico = db.Column(db.String(20), unique=True, nullable=True) 
    nombre = db.Column(db.String(100), nullable=False)
    primer_apellido = db.Column(db.String(100), nullable=False)
    segundo_apellido = db.Column(db.String(100), nullable=True)
    correo = db.Column(db.String(255), unique=True, nullable=False) 
    contrasena_hash = db.Column(db.String(255), nullable=False) 
    rol = db.Column(db.String(50), default="alumno") 
    
    # Verificaci√≥n de correo
    correo_verificado = db.Column(db.Boolean, default=False)
    codigo_verificacion = db.Column(db.String(6), nullable=True)
    expira_verificacion = db.Column(db.DateTime, nullable=True)
    
    # Recuperaci√≥n de contrase√±a
    token_recuperacion = db.Column(db.String(256), nullable=True, unique=True)
    expira_token_recuperacion = db.Column(db.DateTime, nullable=True)
    
    # Estado de cuenta (soft delete)
    estado_cuenta = db.Column(db.String(20), default="activo", nullable=False) 
    fecha_desactivacion = db.Column(db.DateTime, nullable=True)
    
    # Timestamps
    creado_en = db.Column(db.DateTime, default=db.func.now()) 
    actualizado_en = db.Column(db.DateTime, default=db.func.now(), onupdate=db.func.now())

    # Relaciones (ACTUALIZADAS)
    perfil = db.relationship("PerfilUsuario", back_populates="usuario", uselist=False, cascade="all, delete-orphan")
    perfil_estudiante = db.relationship("PerfilEstudiante", back_populates="usuario", uselist=False, cascade="all, delete-orphan")
    perfil_profesor = db.relationship("PerfilProfesor", back_populates="usuario", uselist=False, cascade="all, delete-orphan")
    perfil_admin = db.relationship("PerfilAdministrador", back_populates="usuario", uselist=False, cascade="all, delete-orphan")

    def set_password(self, password):
        """Genera el hash de la contrase√±a"""
        self.contrasena_hash = generate_password_hash(password)

    def check_password(self, password):
        """Verifica la contrase√±a"""
        if not self.contrasena_hash:
            return False
        return check_password_hash(self.contrasena_hash, password)

    def __repr__(self):
        return f"<Usuario {self.id}: {self.correo}>"


# ============================================================
# PERFIL BASE (MODIFICADO - SIN CAMPOS DE ESTUDIANTE)
# ============================================================

class PerfilUsuario(db.Model):
    __tablename__ = "perfil_usuarios"

    id = db.Column(db.Integer, primary_key=True)
    usuario_id = db.Column(db.Integer, db.ForeignKey("usuarios.id"), unique=True, nullable=False) 
    nombre_completo = db.Column(db.String(255), nullable=False) 
    id_publico = db.Column(db.String(20), nullable=True)
    
    # Informaci√≥n general (para todos los roles)
    foto_perfil = db.Column(db.String(500), nullable=True)
    biografia = db.Column(db.Text, nullable=True)
    
    # ELIMINADOS: idioma, nivel_actual, curso_actual, total_xp, dias_racha, ultima_actividad
    # Esos campos ahora est√°n en PerfilEstudiante
    
    # Timestamps
    creado_en = db.Column(db.DateTime, default=db.func.now()) 
    actualizado_en = db.Column(db.DateTime, default=db.func.now(), onupdate=db.func.now())

    # Relaci√≥n inversa con Usuario
    usuario = db.relationship("Usuario", back_populates="perfil")

    def __repr__(self):
        return f"<PerfilUsuario {self.nombre_completo}>"


# ============================================================
# PERFIL ESTUDIANTE (NUEVO)
# ============================================================

class PerfilEstudiante(db.Model):
    __tablename__ = "perfil_estudiantes"

    id = db.Column(db.Integer, primary_key=True)
    usuario_id = db.Column(db.Integer, db.ForeignKey("usuarios.id"), unique=True, nullable=False)
    
    # Informaci√≥n acad√©mica
    nivel_actual = db.Column(db.String(50), nullable=True)
    idioma_aprendizaje = db.Column(db.String(100), nullable=True)
    
    # Gamificaci√≥n
    total_xp = db.Column(db.Integer, default=0)
    nivel_usuario = db.Column(db.Integer, default=1)
    dias_racha = db.Column(db.Integer, default=0)
    ultima_actividad = db.Column(db.Date, nullable=True)
    racha_maxima = db.Column(db.Integer, default=0)
    
    # Progreso
    lecciones_completadas = db.Column(db.Integer, default=0)
    tiempo_estudio_total = db.Column(db.Integer, default=0)  # en minutos
    
    # Configuraci√≥n
    meta_diaria = db.Column(db.Integer, default=30)  # minutos
    notificaciones_habilitadas = db.Column(db.Boolean, default=True)
    
    # Relaci√≥n con Usuario
    usuario = db.relationship("Usuario", back_populates="perfil_estudiante")

    def __repr__(self):
        return f"<PerfilEstudiante Usuario:{self.usuario_id}>"


# ============================================================
# PERFIL PROFESOR (NUEVO)
# ============================================================

class PerfilProfesor(db.Model):
    __tablename__ = "perfil_profesores"

    id = db.Column(db.Integer, primary_key=True)
    usuario_id = db.Column(db.Integer, db.ForeignKey("usuarios.id"), unique=True, nullable=False)
    
    # Informaci√≥n profesional
    especialidad = db.Column(db.String(200), nullable=True)
    a√±os_experiencia = db.Column(db.Integer, nullable=True)
    idiomas_ensena = db.Column(JSON, nullable=True)  # Array: ["ingl√©s", "franc√©s"]
    niveles_ensena = db.Column(JSON, nullable=True)  # Array: ["principiante", "intermedio"]
    certificaciones = db.Column(db.Text, nullable=True)
    descripcion_profesional = db.Column(db.Text, nullable=True)
    
    # Estad√≠sticas
    estudiantes_totales = db.Column(db.Integer, default=0)
    cursos_creados = db.Column(db.Integer, default=0)
    calificacion_promedio = db.Column(Numeric(3, 2), default=0.00)
    total_resenas = db.Column(db.Integer, default=0)
    
    # Relaci√≥n con Usuario
    usuario = db.relationship("Usuario", back_populates="perfil_profesor")

    def __repr__(self):
        return f"<PerfilProfesor Usuario:{self.usuario_id}>"


# ============================================================
# PERFIL ADMINISTRADOR (NUEVO)
# ============================================================

class PerfilAdministrador(db.Model):
    __tablename__ = "perfil_administradores"

    id = db.Column(db.Integer, primary_key=True)
    usuario_id = db.Column(db.Integer, db.ForeignKey("usuarios.id"), unique=True, nullable=False)
    
    # Informaci√≥n administrativa
    departamento = db.Column(db.String(100), nullable=True)
    nivel_acceso = db.Column(db.String(50), default="admin")  # admin, superadmin, mantenimiento
    permisos = db.Column(JSON, nullable=True)  # Array de permisos
    ultimo_acceso_admin = db.Column(db.DateTime, nullable=True)
    
    # Relaci√≥n con Usuario
    usuario = db.relationship("Usuario", back_populates="perfil_admin")

    def __repr__(self):
        return f"<PerfilAdministrador Usuario:{self.usuario_id}>"


================================================================================
# ARCHIVO: back-end/requirements.txt
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/requirements.txt
================================================================================

# ==========================================================
# DEPENDENCIAS DE SPEAKLEXI BACKEND
# ==========================================================

# Framework principal
Flask==2.3.3
Werkzeug==2.3.7

# Base de datos
Flask-SQLAlchemy==3.0.5
SQLAlchemy==2.0.20
PyMySQL==1.1.0

# Autenticaci√≥n y seguridad
Flask-JWT-Extended==4.5.2
Flask-Bcrypt==1.0.1

# Correo electr√≥nico
Flask-Mail==0.9.1

# CORS (Cross-Origin Resource Sharing)
Flask-CORS==4.0.0

# Variables de entorno
python-dotenv==1.0.0

# Validaci√≥n de datos
Flask-WTF==1.1.1
WTForms==3.0.1

# Utilidades
python-dateutil==2.8.2

# Testing (opcional)
pytest==7.4.2
pytest-flask==1.2.0


================================================================================
# ARCHIVO: back-end/routes/__init__.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/__init__.py
================================================================================

from routes.auth import auth_bp
from routes.usuario_routes import usuario_bp
from routes.leccion_routes import leccion_bp
from routes.multimedia_routes import multimedia_bp
from routes.curso_routes import curso_bp  # ‚Üê AGREGAR
from routes.actividades_routes import actividades_bp  # ‚Üê AGREGAR

def register_routes(app):
    app.register_blueprint(auth_bp)
    app.register_blueprint(usuario_bp)
    app.register_blueprint(leccion_bp)
    app.register_blueprint(multimedia_bp)
    app.register_blueprint(curso_bp)  # ‚Üê AGREGAR
    app.register_blueprint(actividades_bp)  # ‚Üê AGREGAR


================================================================================
# ARCHIVO: back-end/routes/actividades_routes.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/actividades_routes.py
================================================================================

# back-end/routes/actividades_routes.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from models.leccion import Actividad, Leccion
from models.usuario import Usuario
from extensions import db

actividades_bp = Blueprint('actividades', __name__, url_prefix='/api/actividades')


@actividades_bp.route('', methods=['POST'])
@jwt_required()
def crear_actividad():
    """
    Crear nueva actividad para una lecci√≥n
    Body:
    {
        "leccion_id": 1,
        "tipo": "multiple_choice",
        "pregunta": "What is the capital of France?",
        "instrucciones": "Select the correct answer",
        "opciones": ["London", "Paris", "Berlin", "Madrid"],
        "respuesta_correcta": "Paris",
        "pista": "It's known as the City of Light",
        "puntos": 10,
        "orden": 1,
        "multimedia_id": null
    }
    """
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol not in ['admin', 'profesor']:
            return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        data = request.json
        
        # Validar campos requeridos
        if 'leccion_id' not in data or 'tipo' not in data or 'pregunta' not in data:
            return jsonify({
                'success': False,
                'error': 'Campos requeridos: leccion_id, tipo, pregunta'
            }), 400
        
        # Validar que la lecci√≥n existe
        leccion = Leccion.query.get(data['leccion_id'])
        if not leccion:
            return jsonify({'success': False, 'error': 'Lecci√≥n no encontrada'}), 404
        
        # Validar tipo de actividad
        tipos_validos = ['multiple_choice', 'fill_blank', 'matching', 'translation', 
                        'listen_repeat', 'true_false', 'word_order']
        if data['tipo'] not in tipos_validos:
            return jsonify({
                'success': False,
                'error': f'Tipo inv√°lido. Use: {", ".join(tipos_validos)}'
            }), 400
        
        # Si es profesor, verificar que sea su lecci√≥n
        if usuario.rol == 'profesor':
            if leccion.curso_id:
                from models.cursos import Curso
                curso = Curso.query.get(leccion.curso_id)
                if curso and curso.profesor_id != usuario_id:
                    return jsonify({
                        'success': False,
                        'error': 'No puedes crear actividades en esta lecci√≥n'
                    }), 403
        
        # Determinar el siguiente orden si no se especifica
        if 'orden' not in data:
            ultima_actividad = Actividad.query.filter_by(
                leccion_id=data['leccion_id']
            ).order_by(Actividad.orden.desc()).first()
            data['orden'] = (ultima_actividad.orden + 1) if ultima_actividad else 1
        
        # Crear actividad
        nueva_actividad = Actividad(
            leccion_id=data['leccion_id'],
            tipo=data['tipo'],
            pregunta=data['pregunta'],
            instrucciones=data.get('instrucciones'),
            opciones=data.get('opciones'),
            respuesta_correcta=data.get('respuesta_correcta', {}),
            retroalimentacion=data.get('retroalimentacion'),
            pista=data.get('pista'),
            puntos=data.get('puntos', 10),
            orden=data['orden'],
            tiempo_limite=data.get('tiempo_limite'),
            multimedia_id=data.get('multimedia_id')
        )
        
        db.session.add(nueva_actividad)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': 'Actividad creada exitosamente',
            'actividad': nueva_actividad.to_dict()
        }), 201
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@actividades_bp.route('/leccion/<int:leccion_id>', methods=['GET'])
def obtener_actividades_leccion(leccion_id):
    """Obtener todas las actividades de una lecci√≥n"""
    try:
        leccion = Leccion.query.get_or_404(leccion_id)
        
        actividades = Actividad.query.filter_by(
            leccion_id=leccion_id
        ).order_by(Actividad.orden).all()
        
        return jsonify({
            'success': True,
            'leccion_id': leccion_id,
            'actividades': [a.to_dict() for a in actividades],
            'total': len(actividades)
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@actividades_bp.route('/<int:actividad_id>', methods=['GET'])
def obtener_actividad(actividad_id):
    """Obtener una actividad espec√≠fica"""
    try:
        actividad = Actividad.query.get_or_404(actividad_id)
        
        return jsonify({
            'success': True,
            'actividad': actividad.to_dict()
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@actividades_bp.route('/<int:actividad_id>', methods=['PUT'])
@jwt_required()
def actualizar_actividad(actividad_id):
    """Actualizar una actividad"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol not in ['admin', 'profesor']:
            return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        actividad = Actividad.query.get_or_404(actividad_id)
        
        # Si es profesor, verificar permisos
        if usuario.rol == 'profesor':
            leccion = Leccion.query.get(actividad.leccion_id)
            if leccion.curso_id:
                from models.cursos import Curso
                curso = Curso.query.get(leccion.curso_id)
                if curso and curso.profesor_id != usuario_id:
                    return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        data = request.json
        
        # Actualizar campos permitidos
        campos_permitidos = [
            'pregunta', 'instrucciones', 'opciones', 'respuesta_correcta',
            'retroalimentacion', 'pista', 'puntos', 'orden', 'tiempo_limite',
            'multimedia_id'
        ]
        
        for campo in campos_permitidos:
            if campo in data:
                setattr(actividad, campo, data[campo])
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': 'Actividad actualizada',
            'actividad': actividad.to_dict()
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@actividades_bp.route('/<int:actividad_id>', methods=['DELETE'])
@jwt_required()
def eliminar_actividad(actividad_id):
    """Eliminar una actividad"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol not in ['admin', 'profesor']:
            return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        actividad = Actividad.query.get_or_404(actividad_id)
        
        # Verificar permisos si es profesor
        if usuario.rol == 'profesor':
            leccion = Leccion.query.get(actividad.leccion_id)
            if leccion.curso_id:
                from models.cursos import Curso
                curso = Curso.query.get(leccion.curso_id)
                if curso and curso.profesor_id != usuario_id:
                    return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        leccion_id = actividad.leccion_id
        pregunta = actividad.pregunta
        
        db.session.delete(actividad)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': f'Actividad eliminada: {pregunta}'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@actividades_bp.route('/<int:actividad_id>/validar', methods=['POST'])
@jwt_required()
def validar_respuesta(actividad_id):
    """
    Validar respuesta de estudiante
    Body: {"respuesta": "..."}
    """
    try:
        usuario_id = get_jwt_identity()
        
        actividad = Actividad.query.get_or_404(actividad_id)
        data = request.json
        
        if 'respuesta' not in data:
            return jsonify({
                'success': False,
                'error': 'Campo requerido: respuesta'
            }), 400
        
        respuesta_usuario = data['respuesta']
        respuesta_correcta = actividad.respuesta_correcta
        
        # Validar seg√∫n tipo de actividad
        es_correcta = False
        
        if actividad.tipo == 'multiple_choice':
            es_correcta = str(respuesta_usuario).lower() == str(respuesta_correcta).lower()
        
        elif actividad.tipo == 'true_false':
            es_correcta = bool(respuesta_usuario) == bool(respuesta_correcta)
        
        elif actividad.tipo == 'fill_blank':
            # Normalizar y comparar
            es_correcta = str(respuesta_usuario).strip().lower() == str(respuesta_correcta).strip().lower()
        
        elif actividad.tipo == 'matching':
            # Comparar diccionarios o arrays
            es_correcta = respuesta_usuario == respuesta_correcta
        
        elif actividad.tipo == 'word_order':
            # Validar orden de palabras
            es_correcta = respuesta_usuario == respuesta_correcta
        
        elif actividad.tipo == 'translation':
            # Para traducciones, podr√≠a ser m√°s flexible
            es_correcta = str(respuesta_usuario).strip().lower() == str(respuesta_correcta).strip().lower()
        
        # Obtener retroalimentaci√≥n
        retroalimentacion = None
        if actividad.retroalimentacion:
            if isinstance(actividad.retroalimentacion, dict):
                retroalimentacion = actividad.retroalimentacion.get(
                    'correcta' if es_correcta else 'incorrecta'
                )
            else:
                retroalimentacion = actividad.retroalimentacion
        
        puntos_ganados = actividad.puntos if es_correcta else 0
        
        return jsonify({
            'success': True,
            'correcta': es_correcta,
            'puntos_ganados': puntos_ganados,
            'respuesta_correcta': respuesta_correcta if not es_correcta else None,
            'retroalimentacion': retroalimentacion,
            'pista': actividad.pista if not es_correcta else None
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@actividades_bp.route('/tipos', methods=['GET'])
def obtener_tipos_actividades():
    """Obtener lista de tipos de actividades disponibles"""
    tipos = [
        {
            'value': 'multiple_choice',
            'label': 'Opci√≥n M√∫ltiple',
            'icon': 'üéØ',
            'descripcion': 'Seleccionar la respuesta correcta entre varias opciones'
        },
        {
            'value': 'fill_blank',
            'label': 'Completar Espacios',
            'icon': '‚úèÔ∏è',
            'descripcion': 'Llenar espacios en blanco en una oraci√≥n'
        },
        {
            'value': 'matching',
            'label': 'Emparejar',
            'icon': 'üîó',
            'descripcion': 'Conectar elementos relacionados'
        },
        {
            'value': 'translation',
            'label': 'Traducci√≥n',
            'icon': 'üåê',
            'descripcion': 'Traducir palabras o frases'
        },
        {
            'value': 'listen_repeat',
            'label': 'Escuchar y Repetir',
            'icon': 'üé§',
            'descripcion': 'Pr√°ctica de pronunciaci√≥n con audio'
        },
        {
            'value': 'true_false',
            'label': 'Verdadero/Falso',
            'icon': '‚úì‚úó',
            'descripcion': 'Determinar si una afirmaci√≥n es verdadera o falsa'
        },
        {
            'value': 'word_order',
            'label': 'Ordenar Palabras',
            'icon': 'üìù',
            'descripcion': 'Organizar palabras en el orden correcto'
        }
    ]
    
    return jsonify({
        'success': True,
        'tipos': tipos
    }), 200


================================================================================
# ARCHIVO: back-end/routes/auth.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/auth.py
================================================================================

from flask import Blueprint, request, jsonify
# IMPORTACI√ìN ACTUALIZADA: Importar la clase Usuario directamente
from models.usuario import Usuario
# IMPORTACI√ìN NECESARIA para JWT
from flask_jwt_extended import create_access_token, create_refresh_token
# Importar el gestor (asumiendo que est√° actualizado para los nuevos perfiles)
from services.gestor_usuarios import GestorUsuarios

# ========================================
# BLUEPRINT DE AUTENTICACI√ìN
# ========================================
# ‚úÖ ESTA L√çNEA ES LA IMPORTANTE que faltaba o estaba incorrecta
auth_bp = Blueprint("auth", __name__, url_prefix="/api/auth")
gestor = GestorUsuarios() # Instancia del gestor

# ========================================
# MANEJO DE PREFLIGHT REQUESTS (CORS) - Opcional aqu√≠ si ya est√° en app.py
# ========================================
# Puedes mantener o quitar este bloque si ya lo gestionas globalmente en app.py
@auth_bp.before_request
def handle_preflight():
    """Permite manejar solicitudes OPTIONS de CORS"""
    if request.method == "OPTIONS":
        # Respuesta simple para preflight, flask_cors usualmente maneja los headers
        return "", 204

# ========================================
# REGISTRO Y VERIFICACI√ìN (Usa el gestor actualizado)
# ========================================
@auth_bp.route("/register", methods=["POST"])
def registrar():
    """Registra un nuevo usuario (asume rol 'alumno' por defecto)"""
    data = request.get_json()
    if not data:
        return jsonify({"error": "No se recibieron datos JSON"}), 400

    nombre = data.get("nombre")
    primer_apellido = data.get("primer_apellido")
    segundo_apellido = data.get("segundo_apellido")
    correo = data.get("correo")
    password = data.get("password")
    # Datos opcionales para perfil estudiante
    idioma = data.get("idioma", "Ingl√©s")
    nivel_actual = data.get("nivel_actual", "A1")

    # Validaci√≥n b√°sica
    campos_obligatorios = {'nombre': nombre, 'primer_apellido': primer_apellido, 'correo': correo, 'password': password}
    campos_faltantes = [k for k, v in campos_obligatorios.items() if not v]
    if campos_faltantes:
        return jsonify({"error": f"Faltan datos obligatorios: {', '.join(campos_faltantes)}"}), 400

    # Llamar al gestor para registrar (asume rol 'alumno')
    # El gestor ahora debe crear Usuario, PerfilUsuario (base) y PerfilEstudiante
    respuesta, codigo = gestor.registrar_usuario(
        nombre, primer_apellido, segundo_apellido,
        correo, password,
        # Pasar datos espec√≠ficos del perfil estudiante
        datos_perfil={'idioma_aprendizaje': idioma, 'nivel_actual': nivel_actual}
    )
    return jsonify(respuesta), codigo

@auth_bp.route("/verificar-email", methods=["POST"])
def verificar_email():
    """Verifica el correo con c√≥digo de 6 d√≠gitos"""
    data = request.get_json()
    correo = data.get("correo")
    codigo = data.get("codigo")

    if not correo or not codigo:
        return jsonify({"error": "Correo y c√≥digo son requeridos"}), 400

    respuesta, codigo_http = gestor.verificar_correo(correo, codigo)
    return jsonify(respuesta), codigo_http

@auth_bp.route("/reenviar-codigo", methods=["POST"])
def reenviar_codigo():
    """Reenv√≠a el c√≥digo de verificaci√≥n"""
    data = request.get_json()
    correo = data.get("correo")

    if not correo:
        return jsonify({"error": "Correo requerido"}), 400

    respuesta, codigo_http = gestor.reenviar_codigo(correo)
    return jsonify(respuesta), codigo_http

# ========================================
# AUTENTICACI√ìN (Usa gestor y a√±ade token)
# ========================================
@auth_bp.route("/login", methods=["POST"])
def login():
    """Inicia sesi√≥n, devuelve datos del usuario, perfil espec√≠fico y token JWT"""
    data = request.get_json()
    correo = data.get("correo")
    password = data.get("password")

    if not correo or not password:
        return jsonify({"error": "Faltan credenciales (correo y contrase√±a)"}), 400

    # Autenticar usando el gestor
    respuesta_auth, codigo_auth = gestor.autenticar_usuario(correo, password)

    # --- MANEJO DE ERRORES DE AUTENTICACI√ìN ---
    if codigo_auth != 200:
        # Si la cuenta est√° desactivada, a√±adir ID si es posible
        if codigo_auth == 403 and respuesta_auth.get("codigo") == "CUENTA_DESACTIVADA":
            try:
                # No necesitas importar Usuario aqu√≠ si ya lo hace el gestor
                usuario_desactivado = Usuario.query.filter_by(correo=correo).first()
                if usuario_desactivado:
                    respuesta_auth["usuario_id"] = usuario_desactivado.id
            except Exception as e:
                 print(f"‚ö†Ô∏è Error al buscar ID de usuario desactivado {correo}: {e}")
                 pass
        return jsonify(respuesta_auth), codigo_auth

    # --- LOGIN EXITOSO: Generar Token y Devolver Datos Completos ---
    try:
        # El gestor ahora deber√≠a devolver el usuario con su perfil espec√≠fico
        usuario_data_completa = respuesta_auth.get('usuario')
        if not usuario_data_completa or 'id' not in usuario_data_completa:
            print(f"‚ùå Error cr√≠tico: Gestor.autenticar_usuario no devolvi√≥ 'usuario' con 'id'. Respuesta: {respuesta_auth}")
            return jsonify({"error": "Error interno del servidor al procesar la autenticaci√≥n"}), 500

        usuario_id = usuario_data_completa['id']

        # Crear tokens JWT (identidad como string)
        access_token = create_access_token(identity=str(usuario_id))
        # refresh_token = create_refresh_token(identity=str(usuario_id)) # Opcional

        # Construir la respuesta final
        respuesta_final = {
            "mensaje": "Inicio de sesi√≥n exitoso",
            "access_token": access_token,
            # "refresh_token": refresh_token, # Incluir si se usa
            "usuario": usuario_data_completa # Ya incluye perfil base y espec√≠fico
        }

        return jsonify(respuesta_final), 200

    except Exception as e:
        print(f"‚ùå Error inesperado durante la generaci√≥n del token o construcci√≥n de respuesta para {correo}: {e}")
        return jsonify({"error": f"Error interno del servidor despu√©s de la autenticaci√≥n: {str(e)}"}), 500


# ========================================
# RECUPERACI√ìN DE CONTRASE√ëA (Usa gestor)
# ========================================
@auth_bp.route("/recuperar-password", methods=["POST"])
def recuperar_password():
    """Inicia el proceso de recuperaci√≥n de contrase√±a"""
    data = request.get_json()
    correo = data.get("correo")

    if not correo:
        return jsonify({"error": "Correo requerido"}), 400

    respuesta, codigo = gestor.solicitar_recuperacion_password(correo)
    return jsonify(respuesta), codigo

@auth_bp.route("/validar-token-recuperacion", methods=["POST"])
def validar_token():
    """Valida que el token de recuperaci√≥n sea v√°lido"""
    data = request.get_json()
    token = data.get("token")

    if not token:
        return jsonify({"error": "Token requerido"}), 400

    respuesta, codigo = gestor.validar_token_recuperacion(token)
    return jsonify(respuesta), codigo

@auth_bp.route("/restablecer-password", methods=["POST"])
def restablecer_password():
    """Restablece la contrase√±a usando el token"""
    data = request.get_json()
    token = data.get("token")
    nueva_password = data.get("nueva_password")

    if not token or not nueva_password:
        return jsonify({"error": "Token y nueva contrase√±a son requeridos"}), 400

    if len(nueva_password) < 8:
        return jsonify({"error": "La contrase√±a debe tener al menos 8 caracteres"}), 400

    respuesta, codigo = gestor.restablecer_password(token, nueva_password)
    return jsonify(respuesta), codigo

# ========================================
# RUTA DE PRUEBA (Opcional)
# ========================================
@auth_bp.route("/test", methods=["GET"])
def test():
    """Ruta de prueba para verificar que el blueprint funciona"""
    return jsonify({"mensaje": "Blueprint de auth funcionando correctamente"}), 200




================================================================================
# ARCHIVO: back-end/routes/curso_routes.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/curso_routes.py
================================================================================

# back-end/routes/curso_routes.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from models.cursos import Curso, ProgresoCurso
from models.usuario import Usuario
from models.leccion import Leccion
from extensions import db
from sqlalchemy import func, or_

curso_bp = Blueprint('cursos', __name__, url_prefix='/api/cursos')


@curso_bp.route('', methods=['GET'])
def obtener_cursos():
    """
    Obtener lista de cursos con filtros opcionales
    Query params:
    - idioma: filtrar por idioma (default: ingles)
    - nivel: filtrar por nivel espec√≠fico (A1, A2, etc)
    - activos: solo cursos activos (default: true)
    - profesor_id: cursos de un profesor espec√≠fico
    """
    try:
        idioma = request.args.get('idioma', 'ingles')
        nivel = request.args.get('nivel')
        solo_activos = request.args.get('activos', 'true').lower() == 'true'
        profesor_id = request.args.get('profesor_id')
        
        query = Curso.query
        
        if solo_activos:
            query = query.filter_by(activo=True)
        
        query = query.filter_by(idioma=idioma)
        
        if nivel:
            query = query.filter_by(nivel=nivel)
        
        if profesor_id:
            query = query.filter_by(profesor_id=profesor_id)
        
        cursos = query.order_by(Curso.orden).all()
        
        return jsonify({
            'success': True,
            'cursos': [c.to_dict() for c in cursos],
            'total': len(cursos)
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>', methods=['GET'])
def obtener_curso(curso_id):
    """Obtener detalles de un curso espec√≠fico"""
    try:
        incluir_lecciones = request.args.get('lecciones', 'false').lower() == 'true'
        
        curso = Curso.query.get_or_404(curso_id)
        
        return jsonify({
            'success': True,
            'curso': curso.to_dict(incluir_lecciones=incluir_lecciones)
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('', methods=['POST'])
@jwt_required()
def crear_curso():
    """
    Crear nuevo curso (Solo Admin/Profesor)
    Body JSON:
    {
        "nombre": "Ingl√©s B√°sico A1",
        "nivel": "A1",
        "descripcion": "Curso para principiantes",
        "idioma": "ingles",
        "codigo": "ENG-A1",
        "profesor_id": 2,
        "objetivos_aprendizaje": ["Objetivo 1", "Objetivo 2"]
    }
    """
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol not in ['admin', 'profesor']:
            return jsonify({
                'success': False, 
                'error': 'No autorizado. Solo administradores y profesores pueden crear cursos.'
            }), 403
        
        data = request.json
        
        # Validar campos requeridos
        campos_requeridos = ['nombre', 'nivel', 'idioma', 'codigo']
        for campo in campos_requeridos:
            if campo not in data:
                return jsonify({
                    'success': False, 
                    'error': f'Campo requerido: {campo}'
                }), 400
        
        # Validar que el c√≥digo no exista
        if Curso.query.filter_by(codigo=data['codigo']).first():
            return jsonify({
                'success': False, 
                'error': 'El c√≥digo de curso ya existe'
            }), 400
        
        # Validar nivel
        niveles_validos = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']
        if data['nivel'].upper() not in niveles_validos:
            return jsonify({
                'success': False, 
                'error': f'Nivel inv√°lido. Use: {", ".join(niveles_validos)}'
            }), 400
        
        # Si es profesor, asignarlo autom√°ticamente
        profesor_id = data.get('profesor_id')
        if usuario.rol == 'profesor' and not profesor_id:
            profesor_id = usuario_id
        
        nuevo_curso = Curso(
            nombre=data['nombre'],
            nivel=data['nivel'].upper(),
            descripcion=data.get('descripcion'),
            idioma=data['idioma'],
            codigo=data['codigo'].upper(),
            profesor_id=profesor_id,
            imagen_portada=data.get('imagen_portada'),
            orden=data.get('orden', 0),
            activo=data.get('activo', True),
            requisitos_previos=data.get('requisitos_previos'),
            objetivos_aprendizaje=data.get('objetivos_aprendizaje')
        )
        
        db.session.add(nuevo_curso)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': 'Curso creado exitosamente',
            'curso': nuevo_curso.to_dict()
        }), 201
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>', methods=['PUT'])
@jwt_required()
def actualizar_curso(curso_id):
    """Actualizar curso existente"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol not in ['admin', 'profesor']:
            return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        curso = Curso.query.get_or_404(curso_id)
        
        # Si es profesor, verificar que sea su curso
        if usuario.rol == 'profesor' and curso.profesor_id != usuario_id:
            return jsonify({
                'success': False, 
                'error': 'No puedes editar este curso'
            }), 403
        
        data = request.json
        
        # Actualizar campos permitidos
        campos_actualizables = [
            'nombre', 'descripcion', 'profesor_id', 'imagen_portada', 
            'activo', 'requisitos_previos', 'objetivos_aprendizaje', 'orden'
        ]
        
        for campo in campos_actualizables:
            if campo in data:
                setattr(curso, campo, data[campo])
        
        curso.actualizado_en = db.func.now()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': 'Curso actualizado exitosamente',
            'curso': curso.to_dict()
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>', methods=['DELETE'])
@jwt_required()
def eliminar_curso(curso_id):
    """Eliminar curso (Solo Admin)"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol != 'admin':
            return jsonify({'success': False, 'error': 'Solo administradores'}), 403
        
        curso = Curso.query.get_or_404(curso_id)
        
        # Verificar si tiene lecciones
        if curso.total_lecciones > 0:
            return jsonify({
                'success': False,
                'error': 'No se puede eliminar un curso con lecciones. Elimina las lecciones primero.'
            }), 400
        
        db.session.delete(curso)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': f'Curso {curso.codigo} eliminado exitosamente'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>/lecciones', methods=['GET'])
def obtener_lecciones_curso(curso_id):
    """Obtener todas las lecciones de un curso"""
    try:
        curso = Curso.query.get_or_404(curso_id)
        
        estado = request.args.get('estado', 'publicada')
        
        query = curso.lecciones
        if estado:
            query = query.filter_by(estado=estado)
        
        lecciones = query.order_by(Leccion.orden).all()
        
        return jsonify({
            'success': True,
            'curso_id': curso_id,
            'curso_nombre': curso.nombre,
            'lecciones': [l.to_dict() for l in lecciones],
            'total': len(lecciones)
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>/progreso', methods=['GET'])
@jwt_required()
def obtener_progreso_curso(curso_id):
    """Obtener progreso del usuario autenticado en un curso"""
    try:
        usuario_id = get_jwt_identity()
        
        progreso = ProgresoCurso.query.filter_by(
            usuario_id=usuario_id,
            curso_id=curso_id
        ).first()
        
        if not progreso:
            # Crear registro de progreso si no existe
            curso = Curso.query.get_or_404(curso_id)
            progreso = ProgresoCurso(
                usuario_id=usuario_id,
                curso_id=curso_id,
                lecciones_totales=curso.total_lecciones
            )
            db.session.add(progreso)
            db.session.commit()
        
        return jsonify({
            'success': True,
            'progreso': progreso.to_dict(incluir_curso=True)
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>/inscribir', methods=['POST'])
@jwt_required()
def inscribir_en_curso(curso_id):
    """Inscribir al usuario en un curso"""
    try:
        usuario_id = get_jwt_identity()
        
        curso = Curso.query.get_or_404(curso_id)
        
        if not curso.activo:
            return jsonify({
                'success': False,
                'error': 'Este curso no est√° activo'
            }), 400
        
        # Verificar si ya est√° inscrito
        progreso_existente = ProgresoCurso.query.filter_by(
            usuario_id=usuario_id,
            curso_id=curso_id
        ).first()
        
        if progreso_existente:
            return jsonify({
                'success': False,
                'error': 'Ya est√°s inscrito en este curso',
                'progreso': progreso_existente.to_dict()
            }), 400
        
        # Verificar prerequisitos
        if not curso.tiene_prerequisitos_cumplidos(usuario_id):
            return jsonify({
                'success': False,
                'error': 'No cumples con los prerequisitos de este curso'
            }), 400
        
        # Crear progreso
        from datetime import date
        nuevo_progreso = ProgresoCurso(
            usuario_id=usuario_id,
            curso_id=curso_id,
            lecciones_totales=curso.total_lecciones,
            fecha_inicio=date.today(),
            estado='en_progreso'
        )
        
        db.session.add(nuevo_progreso)
        
        # Actualizar perfil del estudiante
        from models.usuario import PerfilEstudiante
        perfil = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
        if perfil:
            perfil.curso_actual_id = curso_id
            perfil.nivel_asignado = curso.nivel
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': f'Te has inscrito en {curso.nombre}',
            'progreso': nuevo_progreso.to_dict(incluir_curso=True)
        }), 201
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>/estadisticas', methods=['GET'])
@jwt_required()
def obtener_estadisticas_curso(curso_id):
    """Obtener estad√≠sticas generales del curso (Admin/Profesor)"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol not in ['admin', 'profesor']:
            return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        curso = Curso.query.get_or_404(curso_id)
        
        # Si es profesor, verificar que sea su curso
        if usuario.rol == 'profesor' and curso.profesor_id != usuario_id:
            return jsonify({'success': False, 'error': 'No es tu curso'}), 403
        
        # Estad√≠sticas de estudiantes
        total_estudiantes = ProgresoCurso.query.filter_by(curso_id=curso_id).count()
        estudiantes_completado = ProgresoCurso.query.filter_by(
            curso_id=curso_id, 
            estado='completado'
        ).count()
        estudiantes_en_progreso = ProgresoCurso.query.filter_by(
            curso_id=curso_id,
            estado='en_progreso'
        ).count()
        
        # Promedio de progreso
        promedio_progreso = db.session.query(
            func.avg(ProgresoCurso.porcentaje_completado)
        ).filter_by(curso_id=curso_id).scalar() or 0
        
        # Promedio de puntuaci√≥n
        promedio_puntuacion = db.session.query(
            func.avg(ProgresoCurso.puntuacion_promedio)
        ).filter_by(curso_id=curso_id).scalar() or 0
        
        # Tiempo promedio dedicado
        tiempo_promedio = db.session.query(
            func.avg(ProgresoCurso.tiempo_dedicado)
        ).filter_by(curso_id=curso_id).scalar() or 0
        
        return jsonify({
            'success': True,
            'estadisticas': {
                'curso_id': curso_id,
                'curso_nombre': curso.nombre,
                'nivel': curso.nivel,
                'total_lecciones': curso.total_lecciones,
                'duracion_total': curso.duracion_estimada_total,
                'estudiantes': {
                    'total': total_estudiantes,
                    'completado': estudiantes_completado,
                    'en_progreso': estudiantes_en_progreso,
                    'no_iniciado': total_estudiantes - estudiantes_completado - estudiantes_en_progreso
                },
                'promedios': {
                    'progreso': round(float(promedio_progreso), 2),
                    'puntuacion': round(float(promedio_puntuacion), 2) if promedio_puntuacion else None,
                    'tiempo_dedicado': round(float(tiempo_promedio), 2)
                }
            }
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>/estudiantes', methods=['GET'])
@jwt_required()
def obtener_estudiantes_curso(curso_id):
    """Obtener lista de estudiantes inscritos en el curso (Admin/Profesor)"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol not in ['admin', 'profesor']:
            return jsonify({'success': False, 'error': 'No autorizado'}), 403
        
        curso = Curso.query.get_or_404(curso_id)
        
        if usuario.rol == 'profesor' and curso.profesor_id != usuario_id:
            return jsonify({'success': False, 'error': 'No es tu curso'}), 403
        
        progresos = ProgresoCurso.query.filter_by(curso_id=curso_id).all()
        
        estudiantes = []
        for progreso in progresos:
            estudiantes.append({
                **progreso.to_dict(incluir_usuario=True),
            })
        
        return jsonify({
            'success': True,
            'curso': curso.to_dict(incluir_profesor=False),
            'estudiantes': estudiantes,
            'total': len(estudiantes)
        }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/<int:curso_id>/activar', methods=['PATCH'])
@jwt_required()
def cambiar_estado_curso(curso_id):
    """Activar/Desactivar curso (Solo Admin)"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol != 'admin':
            return jsonify({'success': False, 'error': 'Solo administradores'}), 403
        
        curso = Curso.query.get_or_404(curso_id)
        curso.activo = not curso.activo
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'mensaje': f'Curso {"activado" if curso.activo else "desactivado"}',
            'activo': curso.activo
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@curso_bp.route('/mis-cursos', methods=['GET'])
@jwt_required()
def obtener_mis_cursos():
    """Obtener cursos del usuario autenticado"""
    try:
        usuario_id = get_jwt_identity()
        usuario = Usuario.query.get(usuario_id)
        
        if usuario.rol == 'profesor':
            # Cursos que imparte
            cursos = Curso.query.filter_by(profesor_id=usuario_id).order_by(Curso.orden).all()
            return jsonify({
                'success': True,
                'tipo': 'profesor',
                'cursos': [c.to_dict() for c in cursos],
                'total': len(cursos)
            }), 200
        
        elif usuario.rol == 'alumno':
            # Cursos en los que est√° inscrito
            progresos = ProgresoCurso.query.filter_by(usuario_id=usuario_id).all()
            cursos_data = [p.to_dict(incluir_curso=True) for p in progresos]
            
            return jsonify({
                'success': True,
                'tipo': 'estudiante',
                'cursos': cursos_data,
                'total': len(cursos_data)
            }), 200
        
        else:
            # Admin ve todos
            cursos = Curso.query.order_by(Curso.orden).all()
            return jsonify({
                'success': True,
                'tipo': 'admin',
                'cursos': [c.to_dict() for c in cursos],
                'total': len(cursos)
            }), 200
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


================================================================================
# ARCHIVO: back-end/routes/leccion_routes.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/leccion_routes.py
================================================================================

"""
Rutas API para gesti√≥n de lecciones y actividades - SpeakLexi
Endpoints REST para el m√≥dulo de lecciones
"""

from flask import Blueprint, request, jsonify
from services.gestor_lecciones import gestor_lecciones
from functools import wraps

# Crear blueprint
leccion_bp = Blueprint('lecciones', __name__, url_prefix='/api/lecciones')


# ========== DECORADORES ==========

def validar_usuario_id(f):
    """Decorador para validar que exista usuario_id en la sesi√≥n/headers"""
    @wraps(f)
    def decorated(*args, **kwargs):
        # TODO: Implementar autenticaci√≥n real con JWT o sesiones
        # Por ahora asumimos usuario_id = 1 para desarrollo
        usuario_id = request.headers.get('X-User-ID', 1)
        request.usuario_id = int(usuario_id)
        return f(*args, **kwargs)
    return decorated


def validar_permisos_admin(f):
    """Decorador para validar permisos de administrador"""
    @wraps(f)
    def decorated(*args, **kwargs):
        # TODO: Implementar verificaci√≥n real de roles
        # Por ahora permite todas las operaciones
        return f(*args, **kwargs)
    return decorated


# ========== ENDPOINTS DE LECCIONES ==========

@leccion_bp.route('/', methods=['GET'])
def listar_lecciones():
    """
    GET /api/lecciones
    Lista todas las lecciones con filtros opcionales
    
    Query params:
        - nivel: principiante|intermedio|avanzado
        - idioma: ingles|espanol|etc
        - categoria: vocabulario|gramatica|etc
        - estado: borrador|publicada|archivada
        - buscar: t√©rmino de b√∫squeda
        - etiqueta: etiqueta espec√≠fica
        - pagina: n√∫mero de p√°gina (default: 1)
        - por_pagina: items por p√°gina (default: 20)
    """
    try:
        # Obtener par√°metros de consulta
        filtros = {
            'nivel': request.args.get('nivel'),
            'idioma': request.args.get('idioma'),
            'categoria': request.args.get('categoria'),
            'estado': request.args.get('estado'),
            'buscar': request.args.get('buscar'),
            'etiqueta': request.args.get('etiqueta')
        }
        
        # Remover valores None
        filtros = {k: v for k, v in filtros.items() if v is not None}
        
        pagina = request.args.get('pagina', 1, type=int)
        por_pagina = request.args.get('por_pagina', 20, type=int)
        
        resultado, codigo = gestor_lecciones.listar_lecciones(
            filtros=filtros,
            pagina=pagina,
            por_pagina=por_pagina
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al listar lecciones: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>', methods=['GET'])
def obtener_leccion(leccion_id):
    """
    GET /api/lecciones/<id>
    Obtiene una lecci√≥n espec√≠fica
    
    Query params:
        - incluir_actividades: true|false (default: false)
        - incluir_multimedia: true|false (default: false)
    """
    try:
        incluir_actividades = request.args.get('incluir_actividades', 'false').lower() == 'true'
        incluir_multimedia = request.args.get('incluir_multimedia', 'false').lower() == 'true'
        
        resultado, codigo = gestor_lecciones.obtener_leccion(
            leccion_id,
            incluir_actividades=incluir_actividades,
            incluir_multimedia=incluir_multimedia
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al obtener lecci√≥n: {str(e)}"}), 500


@leccion_bp.route('/', methods=['POST'])
@validar_usuario_id
@validar_permisos_admin
def crear_leccion():
    """
    POST /api/lecciones
    Crea una nueva lecci√≥n
    
    Body JSON:
    {
        "titulo": "string (requerido)",
        "descripcion": "string",
        "contenido": {}, // JSON con contenido estructurado
        "nivel": "principiante|intermedio|avanzado",
        "idioma": "string",
        "categoria": "string",
        "etiquetas": ["tag1", "tag2"],
        "orden": int,
        "requisitos": [id1, id2], // IDs de lecciones previas
        "duracion_estimada": int, // minutos
        "puntos_xp": int
    }
    """
    try:
        datos = request.get_json()
        
        if not datos:
            return jsonify({"error": "No se proporcionaron datos"}), 400
        
        resultado, codigo = gestor_lecciones.crear_leccion(
            datos,
            request.usuario_id
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al crear lecci√≥n: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>', methods=['PUT', 'PATCH'])
@validar_usuario_id
@validar_permisos_admin
def actualizar_leccion(leccion_id):
    """
    PUT/PATCH /api/lecciones/<id>
    Actualiza una lecci√≥n existente
    
    Body JSON: Campos a actualizar (mismos que POST)
    """
    try:
        datos = request.get_json()
        
        if not datos:
            return jsonify({"error": "No se proporcionaron datos"}), 400
        
        resultado, codigo = gestor_lecciones.actualizar_leccion(
            leccion_id,
            datos,
            request.usuario_id
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al actualizar lecci√≥n: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>', methods=['DELETE'])
@validar_usuario_id
@validar_permisos_admin
def eliminar_leccion(leccion_id):
    """
    DELETE /api/lecciones/<id>
    Elimina (archiva) una lecci√≥n
    """
    try:
        resultado, codigo = gestor_lecciones.eliminar_leccion(
            leccion_id,
            request.usuario_id
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al eliminar lecci√≥n: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>/publicar', methods=['POST'])
@validar_usuario_id
@validar_permisos_admin
def publicar_leccion(leccion_id):
    """
    POST /api/lecciones/<id>/publicar
    Publica una lecci√≥n (cambia estado de borrador a publicada)
    """
    try:
        resultado, codigo = gestor_lecciones.publicar_leccion(
            leccion_id,
            request.usuario_id
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al publicar lecci√≥n: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>/estadisticas', methods=['GET'])
def obtener_estadisticas_leccion(leccion_id):
    """
    GET /api/lecciones/<id>/estadisticas
    Obtiene estad√≠sticas de una lecci√≥n
    """
    try:
        resultado, codigo = gestor_lecciones.obtener_estadisticas_leccion(leccion_id)
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al obtener estad√≠sticas: {str(e)}"}), 500


@leccion_bp.route('/nivel/<string:nivel>', methods=['GET'])
def obtener_lecciones_por_nivel(nivel):
    """
    GET /api/lecciones/nivel/<nivel>
    Obtiene lecciones por nivel de dificultad
    
    Query params:
        - idioma: filtro opcional por idioma
    """
    try:
        idioma = request.args.get('idioma')
        resultado, codigo = gestor_lecciones.obtener_lecciones_por_nivel(nivel, idioma)
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al obtener lecciones: {str(e)}"}), 500


# ========== ENDPOINTS DE ACTIVIDADES ==========

@leccion_bp.route('/<int:leccion_id>/actividades', methods=['POST'])
@validar_usuario_id
@validar_permisos_admin
def agregar_actividad(leccion_id):
    """
    POST /api/lecciones/<id>/actividades
    Agrega una actividad a una lecci√≥n
    
    Body JSON:
    {
        "tipo": "multiple_choice|fill_blank|matching|translation|listen_repeat|true_false|word_order",
        "pregunta": "string (requerido)",
        "instrucciones": "string",
        "opciones": {}, // Estructura var√≠a seg√∫n tipo
        "respuesta_correcta": {}, // Estructura var√≠a seg√∫n tipo
        "retroalimentacion": {
            "correcta": "mensaje",
            "incorrecta": "mensaje"
        },
        "pista": "string",
        "puntos": int,
        "orden": int,
        "tiempo_limite": int, // segundos
        "multimedia_id": int
    }
    """
    try:
        datos = request.get_json()
        
        if not datos:
            return jsonify({"error": "No se proporcionaron datos"}), 400
        
        resultado, codigo = gestor_lecciones.agregar_actividad(leccion_id, datos)
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al agregar actividad: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>/actividades/<int:actividad_id>', methods=['PUT', 'PATCH'])
@validar_usuario_id
@validar_permisos_admin
def actualizar_actividad(leccion_id, actividad_id):
    """
    PUT/PATCH /api/lecciones/<leccion_id>/actividades/<actividad_id>
    Actualiza una actividad
    
    Body JSON: Campos a actualizar (mismos que POST)
    """
    try:
        datos = request.get_json()
        
        if not datos:
            return jsonify({"error": "No se proporcionaron datos"}), 400
        
        resultado, codigo = gestor_lecciones.actualizar_actividad(actividad_id, datos)
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al actualizar actividad: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>/actividades/<int:actividad_id>', methods=['DELETE'])
@validar_usuario_id
@validar_permisos_admin
def eliminar_actividad(leccion_id, actividad_id):
    """
    DELETE /api/lecciones/<leccion_id>/actividades/<actividad_id>
    Elimina una actividad
    """
    try:
        resultado, codigo = gestor_lecciones.eliminar_actividad(actividad_id)
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al eliminar actividad: {str(e)}"}), 500


@leccion_bp.route('/<int:leccion_id>/actividades/<int:actividad_id>/verificar', methods=['POST'])
@validar_usuario_id
def verificar_respuesta(leccion_id, actividad_id):
    """
    POST /api/lecciones/<leccion_id>/actividades/<actividad_id>/verificar
    Verifica la respuesta de un usuario a una actividad
    
    Body JSON:
    {
        "respuesta": <any> // Formato depende del tipo de actividad
    }
    """
    try:
        datos = request.get_json()
        
        if not datos or 'respuesta' not in datos:
            return jsonify({"error": "Debe proporcionar una respuesta"}), 400
        
        resultado, codigo = gestor_lecciones.verificar_respuesta_actividad(
            actividad_id,
            datos['respuesta']
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al verificar respuesta: {str(e)}"}), 500


# ========== MANEJO DE ERRORES ==========

@leccion_bp.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Recurso no encontrado"}), 404


@leccion_bp.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Error interno del servidor"}), 500


# ========== INFORMACI√ìN DEL BLUEPRINT ==========

@leccion_bp.route('/info', methods=['GET'])
def info():
    """Informaci√≥n sobre los endpoints disponibles"""
    return jsonify({
        "nombre": "API de Lecciones - SpeakLexi",
        "version": "1.0.0",
        "endpoints": {
            "lecciones": {
                "GET /api/lecciones": "Listar lecciones con filtros",
                "GET /api/lecciones/<id>": "Obtener lecci√≥n espec√≠fica",
                "POST /api/lecciones": "Crear nueva lecci√≥n",
                "PUT /api/lecciones/<id>": "Actualizar lecci√≥n",
                "DELETE /api/lecciones/<id>": "Eliminar lecci√≥n",
                "POST /api/lecciones/<id>/publicar": "Publicar lecci√≥n",
                "GET /api/lecciones/<id>/estadisticas": "Estad√≠sticas de lecci√≥n",
                "GET /api/lecciones/nivel/<nivel>": "Lecciones por nivel"
            },
            "actividades": {
                "POST /api/lecciones/<id>/actividades": "Agregar actividad",
                "PUT /api/lecciones/<id>/actividades/<aid>": "Actualizar actividad",
                "DELETE /api/lecciones/<id>/actividades/<aid>": "Eliminar actividad",
                "POST /api/lecciones/<id>/actividades/<aid>/verificar": "Verificar respuesta"
            }
        }
    }), 200


================================================================================
# ARCHIVO: back-end/routes/multimedia_routes.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/multimedia_routes.py
================================================================================

"""
Rutas API para gesti√≥n de recursos multimedia - SpeakLexi
Endpoints REST para subir, gestionar y servir archivos multimedia
"""

from flask import Blueprint, request, jsonify, send_file
from services.gestor_multimedia import gestor_multimedia
from werkzeug.utils import secure_filename
from functools import wraps
from pathlib import Path
import os

# Crear blueprint
multimedia_bp = Blueprint('multimedia', __name__, url_prefix='/api/multimedia')


# ========== CONFIGURACI√ìN ==========

EXTENSIONES_PERMITIDAS = {
    'imagen': {'jpg', 'jpeg', 'png', 'gif', 'webp'},
    'audio': {'mp3', 'wav', 'ogg'},
    'video': {'mp4', 'webm'},
    'documento': {'pdf', 'txt'}
}


# ========== DECORADORES ==========

def validar_usuario_id(f):
    """Decorador para validar que exista usuario_id en la sesi√≥n/headers"""
    @wraps(f)
    def decorated(*args, **kwargs):
        # TODO: Implementar autenticaci√≥n real con JWT o sesiones
        # Por ahora asumimos usuario_id = 1 para desarrollo
        usuario_id = request.headers.get('X-User-ID', 1)
        request.usuario_id = int(usuario_id)
        return f(*args, **kwargs)
    return decorated


def validar_permisos_admin(f):
    """Decorador para validar permisos de administrador"""
    @wraps(f)
    def decorated(*args, **kwargs):
        # TODO: Implementar verificaci√≥n real de roles
        # Por ahora permite todas las operaciones
        return f(*args, **kwargs)
    return decorated


def archivo_permitido(filename, tipo=None):
    """
    Verifica si un archivo tiene extensi√≥n permitida
    
    Args:
        filename (str): Nombre del archivo
        tipo (str): Tipo de multimedia (imagen, audio, video, documento)
    
    Returns:
        bool: True si es permitido
    """
    if '.' not in filename:
        return False
    
    extension = filename.rsplit('.', 1)[1].lower()
    
    if tipo:
        return extension in EXTENSIONES_PERMITIDAS.get(tipo, set())
    
    # Si no se especifica tipo, verificar en todas las categor√≠as
    todas_extensiones = set()
    for exts in EXTENSIONES_PERMITIDAS.values():
        todas_extensiones.update(exts)
    
    return extension in todas_extensiones


# ========== ENDPOINTS DE MULTIMEDIA ==========

@multimedia_bp.route('/', methods=['GET'])
def listar_recursos():
    """
    GET /api/multimedia
    Lista todos los recursos multimedia con filtros opcionales
    
    Query params:
        - tipo: imagen|audio|video|documento
        - categoria: vocabulario|gramatica|pronunciacion|etc
        - estado: pendiente|procesando|disponible|error
        - buscar: t√©rmino de b√∫squeda
        - etiqueta: etiqueta espec√≠fica
        - pagina: n√∫mero de p√°gina (default: 1)
        - por_pagina: items por p√°gina (default: 20)
    """
    try:
        # Obtener par√°metros de consulta
        filtros = {
            'tipo': request.args.get('tipo'),
            'categoria': request.args.get('categoria'),
            'estado': request.args.get('estado'),
            'buscar': request.args.get('buscar'),
            'etiqueta': request.args.get('etiqueta')
        }
        
        # Remover valores None
        filtros = {k: v for k, v in filtros.items() if v is not None}
        
        pagina = request.args.get('pagina', 1, type=int)
        por_pagina = request.args.get('por_pagina', 20, type=int)
        
        resultado, codigo = gestor_multimedia.listar_recursos(
            filtros=filtros,
            pagina=pagina,
            por_pagina=por_pagina
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al listar recursos: {str(e)}"}), 500


@multimedia_bp.route('/<int:multimedia_id>', methods=['GET'])
def obtener_recurso(multimedia_id):
    """
    GET /api/multimedia/<id>
    Obtiene informaci√≥n de un recurso multimedia
    
    Query params:
        - incluir_metadata: true|false (default: false)
    """
    try:
        incluir_metadata = request.args.get('incluir_metadata', 'false').lower() == 'true'
        
        resultado, codigo = gestor_multimedia.obtener_recurso(
            multimedia_id,
            incluir_metadata=incluir_metadata
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al obtener recurso: {str(e)}"}), 500


@multimedia_bp.route('/upload', methods=['POST'])
@validar_usuario_id
def subir_archivo():
    """
    POST /api/multimedia/upload
    Sube un nuevo archivo multimedia
    
    Form data:
        - archivo: File (requerido)
        - descripcion: string
        - alt_text: string
        - categoria: string
        - etiquetas: JSON array como string
        - transcripcion: string (para audio/video)
    """
    try:
        # Verificar que se envi√≥ un archivo
        if 'archivo' not in request.files:
            return jsonify({"error": "No se proporcion√≥ ning√∫n archivo"}), 400
        
        archivo = request.files['archivo']
        
        if archivo.filename == '':
            return jsonify({"error": "No se seleccion√≥ ning√∫n archivo"}), 400
        
        # Obtener datos adicionales del formulario
        datos_adicionales = {
            'descripcion': request.form.get('descripcion'),
            'alt_text': request.form.get('alt_text'),
            'categoria': request.form.get('categoria'),
            'transcripcion': request.form.get('transcripcion')
        }
        
        # Procesar etiquetas si existen
        etiquetas_str = request.form.get('etiquetas')
        if etiquetas_str:
            try:
                import json
                datos_adicionales['etiquetas'] = json.loads(etiquetas_str)
            except:
                datos_adicionales['etiquetas'] = []
        
        # Subir archivo
        resultado, codigo = gestor_multimedia.subir_archivo(
            archivo,
            datos_adicionales,
            request.usuario_id
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al subir archivo: {str(e)}"}), 500


@multimedia_bp.route('/<int:multimedia_id>', methods=['PUT', 'PATCH'])
@validar_usuario_id
def actualizar_recurso(multimedia_id):
    """
    PUT/PATCH /api/multimedia/<id>
    Actualiza informaci√≥n de un recurso multimedia
    
    Body JSON:
    {
        "descripcion": "string",
        "alt_text": "string",
        "transcripcion": "string",
        "etiquetas": ["tag1", "tag2"],
        "categoria": "string"
    }
    """
    try:
        datos = request.get_json()
        
        if not datos:
            return jsonify({"error": "No se proporcionaron datos"}), 400
        
        resultado, codigo = gestor_multimedia.actualizar_recurso(
            multimedia_id,
            datos
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al actualizar recurso: {str(e)}"}), 500


@multimedia_bp.route('/<int:multimedia_id>', methods=['DELETE'])
@validar_usuario_id
@validar_permisos_admin
def eliminar_recurso(multimedia_id):
    """
    DELETE /api/multimedia/<id>
    Elimina un recurso multimedia
    
    Query params:
        - eliminar_archivo: true|false (default: true)
    """
    try:
        eliminar_archivo = request.args.get('eliminar_archivo', 'true').lower() == 'true'
        
        resultado, codigo = gestor_multimedia.eliminar_recurso(
            multimedia_id,
            eliminar_archivo=eliminar_archivo
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al eliminar recurso: {str(e)}"}), 500


@multimedia_bp.route('/<int:multimedia_id>/asociar-leccion/<int:leccion_id>', methods=['POST'])
@validar_usuario_id
@validar_permisos_admin
def asociar_con_leccion(multimedia_id, leccion_id):
    """
    POST /api/multimedia/<id>/asociar-leccion/<leccion_id>
    Asocia un recurso multimedia con una lecci√≥n
    
    Body JSON (opcional):
    {
        "orden": int
    }
    """
    try:
        datos = request.get_json() or {}
        orden = datos.get('orden', 0)
        
        resultado, codigo = gestor_multimedia.asociar_con_leccion(
            multimedia_id,
            leccion_id,
            orden=orden
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al asociar recurso: {str(e)}"}), 500


@multimedia_bp.route('/<int:multimedia_id>/desasociar-leccion/<int:leccion_id>', methods=['DELETE'])
@validar_usuario_id
@validar_permisos_admin
def desasociar_de_leccion(multimedia_id, leccion_id):
    """
    DELETE /api/multimedia/<id>/desasociar-leccion/<leccion_id>
    Desasocia un recurso multimedia de una lecci√≥n
    """
    try:
        resultado, codigo = gestor_multimedia.desasociar_de_leccion(
            multimedia_id,
            leccion_id
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al desasociar recurso: {str(e)}"}), 500


@multimedia_bp.route('/estadisticas', methods=['GET'])
def obtener_estadisticas():
    """
    GET /api/multimedia/estadisticas
    Obtiene estad√≠sticas generales del sistema multimedia
    """
    try:
        resultado, codigo = gestor_multimedia.obtener_estadisticas()
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error al obtener estad√≠sticas: {str(e)}"}), 500


@multimedia_bp.route('/archivo/<path:filename>', methods=['GET'])
def servir_archivo(filename):
    """
    GET /api/multimedia/archivo/<filename>
    Sirve un archivo multimedia est√°tico
    
    Este endpoint permite servir archivos directamente
    """
    try:
        from models.multimedia import ConfiguracionMultimedia
        
        # Obtener ruta base
        ruta_base = ConfiguracionMultimedia.obtener_valor(
            'ruta_almacenamiento',
            'uploads/multimedia'
        )
        
        # Construir ruta completa
        ruta_archivo = Path(ruta_base) / filename
        
        # Verificar que el archivo existe
        if not ruta_archivo.exists():
            return jsonify({"error": "Archivo no encontrado"}), 404
        
        # Verificar que la ruta no sale del directorio permitido
        if not str(ruta_archivo.resolve()).startswith(str(Path(ruta_base).resolve())):
            return jsonify({"error": "Acceso denegado"}), 403
        
        # Servir archivo
        return send_file(
            str(ruta_archivo),
            as_attachment=False,
            mimetype=None  # Flask detectar√° autom√°ticamente
        )
        
    except Exception as e:
        return jsonify({"error": f"Error al servir archivo: {str(e)}"}), 500


# ========== ENDPOINTS DE VALIDACI√ìN ==========

@multimedia_bp.route('/validar-extension', methods=['POST'])
def validar_extension():
    """
    POST /api/multimedia/validar-extension
    Valida si una extensi√≥n de archivo es permitida
    
    Body JSON:
    {
        "filename": "string",
        "tipo": "imagen|audio|video|documento" (opcional)
    }
    """
    try:
        datos = request.get_json()
        
        if not datos or 'filename' not in datos:
            return jsonify({"error": "Debe proporcionar un nombre de archivo"}), 400
        
        filename = datos['filename']
        tipo = datos.get('tipo')
        
        es_valido = archivo_permitido(filename, tipo)
        
        return jsonify({
            "valido": es_valido,
            "filename": filename,
            "tipo": tipo
        }), 200
        
    except Exception as e:
        return jsonify({"error": f"Error al validar extensi√≥n: {str(e)}"}), 500


@multimedia_bp.route('/extensiones-permitidas', methods=['GET'])
def listar_extensiones_permitidas():
    """
    GET /api/multimedia/extensiones-permitidas
    Lista todas las extensiones de archivo permitidas
    
    Query params:
        - tipo: imagen|audio|video|documento (opcional)
    """
    try:
        tipo = request.args.get('tipo')
        
        if tipo:
            extensiones = list(EXTENSIONES_PERMITIDAS.get(tipo, []))
        else:
            extensiones = EXTENSIONES_PERMITIDAS
        
        return jsonify({
            "extensiones": extensiones
        }), 200
        
    except Exception as e:
        return jsonify({"error": f"Error al listar extensiones: {str(e)}"}), 500


# ========== ENDPOINTS DE B√öSQUEDA AVANZADA ==========

@multimedia_bp.route('/buscar', methods=['POST'])
def buscar_recursos():
    """
    POST /api/multimedia/buscar
    B√∫squeda avanzada de recursos multimedia
    
    Body JSON:
    {
        "termino": "string",
        "filtros": {
            "tipo": "imagen|audio|video|documento",
            "categoria": "string",
            "etiquetas": ["tag1", "tag2"],
            "fecha_desde": "YYYY-MM-DD",
            "fecha_hasta": "YYYY-MM-DD",
            "tamano_min": int (bytes),
            "tamano_max": int (bytes)
        },
        "ordenar_por": "fecha|nombre|tamano|veces_usado",
        "orden": "asc|desc",
        "pagina": int,
        "por_pagina": int
    }
    """
    try:
        datos = request.get_json() or {}
        
        # Extraer par√°metros de b√∫squeda
        termino = datos.get('termino')
        filtros = datos.get('filtros', {})
        pagina = datos.get('pagina', 1)
        por_pagina = datos.get('por_pagina', 20)
        
        # Agregar t√©rmino de b√∫squeda a filtros
        if termino:
            filtros['buscar'] = termino
        
        resultado, codigo = gestor_multimedia.listar_recursos(
            filtros=filtros,
            pagina=pagina,
            por_pagina=por_pagina
        )
        
        return jsonify(resultado), codigo
        
    except Exception as e:
        return jsonify({"error": f"Error en b√∫squeda: {str(e)}"}), 500


# ========== MANEJO DE ERRORES ==========

@multimedia_bp.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Recurso no encontrado"}), 404


@multimedia_bp.errorhandler(413)
def file_too_large(error):
    return jsonify({"error": "El archivo es demasiado grande"}), 413


@multimedia_bp.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Error interno del servidor"}), 500


# ========== INFORMACI√ìN DEL BLUEPRINT ==========

@multimedia_bp.route('/info', methods=['GET'])
def info():
    """Informaci√≥n sobre los endpoints disponibles"""
    return jsonify({
        "nombre": "API de Multimedia - SpeakLexi",
        "version": "1.0.0",
        "endpoints": {
            "recursos": {
                "GET /api/multimedia": "Listar recursos con filtros",
                "GET /api/multimedia/<id>": "Obtener recurso espec√≠fico",
                "POST /api/multimedia/upload": "Subir nuevo archivo",
                "PUT /api/multimedia/<id>": "Actualizar recurso",
                "DELETE /api/multimedia/<id>": "Eliminar recurso",
                "GET /api/multimedia/estadisticas": "Estad√≠sticas generales",
                "GET /api/multimedia/archivo/<filename>": "Servir archivo est√°tico"
            },
            "asociaciones": {
                "POST /api/multimedia/<id>/asociar-leccion/<lid>": "Asociar con lecci√≥n",
                "DELETE /api/multimedia/<id>/desasociar-leccion/<lid>": "Desasociar de lecci√≥n"
            },
            "validacion": {
                "POST /api/multimedia/validar-extension": "Validar extensi√≥n de archivo",
                "GET /api/multimedia/extensiones-permitidas": "Listar extensiones permitidas"
            },
            "busqueda": {
                "POST /api/multimedia/buscar": "B√∫squeda avanzada"
            }
        },
        "formatos_soportados": EXTENSIONES_PERMITIDAS
    }), 200


# ========== CONFIGURACI√ìN DE L√çMITES ==========

# Configurar tama√±o m√°ximo de archivo (50 MB por defecto)
# Esto debe configurarse en la app principal:
# app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024


================================================================================
# ARCHIVO: back-end/routes/usuario_routes.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/usuario_routes.py
================================================================================

from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity 
from config.database import db
from models.usuario import Usuario, PerfilUsuario, PerfilEstudiante, PerfilProfesor, PerfilAdministrador

# Crear el Blueprint para las rutas de usuario
usuario_bp = Blueprint("usuario_bp", __name__, url_prefix="/api/usuario")

# ========================================
# ACTUALIZAR NIVEL (SOLO PARA ESTUDIANTES)
# ========================================
@usuario_bp.route("/actualizar-nivel", methods=["PATCH"])
@jwt_required()  # Protegida - usar JWT
def actualizar_nivel():
    """
    Endpoint que actualiza el nivel del estudiante
    tras completar el test o elegir manualmente.
    """
    try:
        identity = get_jwt_identity()
        usuario_id = int(identity)
        
        data = request.get_json()
        nuevo_nivel = data.get("nivel")

        if not nuevo_nivel:
            return jsonify({"error": "Nivel requerido"}), 400

        # Busca al usuario
        usuario = Usuario.query.get(usuario_id)
        if not usuario:
            return jsonify({"error": "Usuario no encontrado"}), 404
        
        # Verificar que sea estudiante
        if usuario.rol != 'alumno':
            return jsonify({"error": "Solo los estudiantes pueden actualizar su nivel"}), 403

        # Busca el perfil de estudiante
        perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
        if not perfil_estudiante:
            return jsonify({"error": "Perfil de estudiante no encontrado"}), 404

        # Actualiza el nivel
        perfil_estudiante.nivel_actual = nuevo_nivel
        db.session.commit()
        
        return jsonify({
            "mensaje": f"Nivel actualizado correctamente a {nuevo_nivel}",
            "nivel": nuevo_nivel
        }), 200
        
    except (ValueError, TypeError):
        return jsonify({"error": "Token inv√°lido"}), 400
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error al actualizar nivel: {e}")
        return jsonify({"error": "Error al guardar cambios en la base de datos"}), 500


# ========================================
# OBTENER PERFIL POR ID (ADAPTADO A ROLES)
# ========================================
@usuario_bp.route("/perfil/<int:usuario_id>", methods=["GET"])
@jwt_required()
def obtener_perfil_por_id(usuario_id):
    """
    Obtiene el perfil completo de un usuario espec√≠fico por su ID.
    Devuelve informaci√≥n diferente seg√∫n el rol del usuario.
    """
    try:
        # Busca el usuario por ID
        usuario = Usuario.query.get(usuario_id)
        if not usuario:
            return jsonify({"error": "Usuario no encontrado"}), 404
        
        # Busca el perfil base
        perfil_base = PerfilUsuario.query.filter_by(usuario_id=usuario_id).first()
        if not perfil_base:
            return jsonify({"error": "Perfil base no encontrado"}), 404
        
        # Construye respuesta base
        datos_respuesta = {
            "id": usuario.id,
            "id_publico": usuario.id_publico,
            "nombre": usuario.nombre,
            "primer_apellido": usuario.primer_apellido,
            "segundo_apellido": usuario.segundo_apellido,
            "correo": usuario.correo,
            "rol": usuario.rol, 
            "correo_verificado": usuario.correo_verificado,
            "estado_cuenta": usuario.estado_cuenta,
            "creado_en": usuario.creado_en.isoformat() if usuario.creado_en else None,
            "actualizado_en": usuario.actualizado_en.isoformat() if usuario.actualizado_en else None,
            "perfil_base": {
                "nombre_completo": perfil_base.nombre_completo,
                "foto_perfil": perfil_base.foto_perfil,
                "biografia": perfil_base.biografia
            }
        }
        
        # Agregar perfil espec√≠fico seg√∫n el rol
        if usuario.rol == 'alumno':
            perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
            if perfil_estudiante:
                datos_respuesta["perfil_estudiante"] = {
                    "nivel_actual": perfil_estudiante.nivel_actual,
                    "idioma_aprendizaje": perfil_estudiante.idioma_aprendizaje,
                    "total_xp": perfil_estudiante.total_xp,
                    "nivel_usuario": perfil_estudiante.nivel_usuario,
                    "dias_racha": perfil_estudiante.dias_racha,
                    "racha_maxima": perfil_estudiante.racha_maxima,
                    "lecciones_completadas": perfil_estudiante.lecciones_completadas,
                    "tiempo_estudio_total": perfil_estudiante.tiempo_estudio_total,
                    "meta_diaria": perfil_estudiante.meta_diaria,
                    "notificaciones_habilitadas": perfil_estudiante.notificaciones_habilitadas,
                    "ultima_actividad": perfil_estudiante.ultima_actividad.isoformat() if perfil_estudiante.ultima_actividad else None
                }
        
        elif usuario.rol == 'profesor':
            perfil_profesor = PerfilProfesor.query.filter_by(usuario_id=usuario_id).first()
            if perfil_profesor:
                datos_respuesta["perfil_profesor"] = {
                    "especialidad": perfil_profesor.especialidad,
                    "a√±os_experiencia": perfil_profesor.a√±os_experiencia,
                    "idiomas_ensena": perfil_profesor.idiomas_ensena,
                    "niveles_ensena": perfil_profesor.niveles_ensena,
                    "certificaciones": perfil_profesor.certificaciones,
                    "descripcion_profesional": perfil_profesor.descripcion_profesional,
                    "estudiantes_totales": perfil_profesor.estudiantes_totales,
                    "cursos_creados": perfil_profesor.cursos_creados,
                    "calificacion_promedio": float(perfil_profesor.calificacion_promedio) if perfil_profesor.calificacion_promedio else 0.0,
                    "total_resenas": perfil_profesor.total_resenas
                }
        
        elif usuario.rol in ('admin', 'mantenimiento'):
            perfil_admin = PerfilAdministrador.query.filter_by(usuario_id=usuario_id).first()
            if perfil_admin:
                datos_respuesta["perfil_admin"] = {
                    "departamento": perfil_admin.departamento,
                    "nivel_acceso": perfil_admin.nivel_acceso,
                    "permisos": perfil_admin.permisos,
                    "ultimo_acceso_admin": perfil_admin.ultimo_acceso_admin.isoformat() if perfil_admin.ultimo_acceso_admin else None
                }
            
        return jsonify(datos_respuesta), 200
        
    except Exception as e:
        print(f"‚ùå Error en obtener_perfil_por_id ({usuario_id}): {e}")
        return jsonify({"error": "Error interno al obtener el perfil"}), 500


# ========================================
# OBTENER PERFIL DEL USUARIO ACTUAL
# ========================================
@usuario_bp.route("/perfil", methods=["GET"])
@jwt_required()
def obtener_perfil_actual():
    """
    Obtiene el perfil completo del usuario actualmente autenticado.
    """
    try:
        identity = get_jwt_identity()
        usuario_id_actual = int(identity)
        return obtener_perfil_por_id(usuario_id_actual)
        
    except (ValueError, TypeError):
        print(f"‚ö†Ô∏è Error: Token conten√≠a identidad no num√©rica: {identity}")
        return jsonify({"error": "Token inv√°lido"}), 400
    except Exception as e:
        print(f"‚ùå Error inesperado en obtener_perfil_actual: {e}") 
        return jsonify({"error": "Error interno al procesar la solicitud"}), 500


# ========================================
# ACTUALIZAR PERFIL DEL USUARIO ACTUAL
# ========================================
@usuario_bp.route("/perfil", methods=["PUT", "PATCH"])
@jwt_required()
def actualizar_perfil_actual():
    """
    Actualiza el perfil del usuario autenticado.
    Permite actualizar tanto perfil base como perfil espec√≠fico seg√∫n rol.
    """
    try:
        identity = get_jwt_identity()
        usuario_id = int(identity)
        data = request.get_json()
        
        usuario = Usuario.query.get(usuario_id)
        if not usuario:
            return jsonify({"error": "Usuario no encontrado"}), 404
        
        # Actualizar perfil base
        perfil_base = PerfilUsuario.query.filter_by(usuario_id=usuario_id).first()
        if perfil_base:
            if 'biografia' in data:
                perfil_base.biografia = data['biografia']
            if 'foto_perfil' in data:
                perfil_base.foto_perfil = data['foto_perfil']
        
        # Actualizar perfil espec√≠fico seg√∫n rol
        if usuario.rol == 'alumno':
            perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
            if perfil_estudiante:
                if 'meta_diaria' in data:
                    perfil_estudiante.meta_diaria = data['meta_diaria']
                if 'notificaciones_habilitadas' in data:
                    perfil_estudiante.notificaciones_habilitadas = data['notificaciones_habilitadas']
                if 'idioma_aprendizaje' in data:
                    perfil_estudiante.idioma_aprendizaje = data['idioma_aprendizaje']
        
        elif usuario.rol == 'profesor':
            perfil_profesor = PerfilProfesor.query.filter_by(usuario_id=usuario_id).first()
            if perfil_profesor:
                if 'especialidad' in data:
                    perfil_profesor.especialidad = data['especialidad']
                if 'descripcion_profesional' in data:
                    perfil_profesor.descripcion_profesional = data['descripcion_profesional']
                if 'a√±os_experiencia' in data:
                    perfil_profesor.a√±os_experiencia = data['a√±os_experiencia']
                if 'certificaciones' in data:
                    perfil_profesor.certificaciones = data['certificaciones']
        
        db.session.commit()
        return jsonify({"mensaje": "Perfil actualizado correctamente"}), 200
        
    except (ValueError, TypeError):
        return jsonify({"error": "Token inv√°lido"}), 400
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error al actualizar perfil {usuario_id}: {e}")
        return jsonify({"error": "Error interno al actualizar perfil"}), 500


# ========================================
# ACTUALIZAR XP DEL ESTUDIANTE
# ========================================
@usuario_bp.route("/actualizar-xp", methods=["PATCH"])
@jwt_required()
def actualizar_xp():
    """
    Actualiza los puntos XP del estudiante.
    Solo disponible para usuarios con rol 'alumno'.
    """
    try:
        identity = get_jwt_identity()
        usuario_id = int(identity)
        data = request.get_json()
        
        xp_ganado = data.get("xp", 0)
        if xp_ganado <= 0:
            return jsonify({"error": "XP debe ser mayor a 0"}), 400
        
        usuario = Usuario.query.get(usuario_id)
        if not usuario or usuario.rol != 'alumno':
            return jsonify({"error": "Solo estudiantes pueden ganar XP"}), 403
        
        perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
        if not perfil_estudiante:
            return jsonify({"error": "Perfil de estudiante no encontrado"}), 404
        
        # Actualizar XP
        perfil_estudiante.total_xp += xp_ganado
        
        # Calcular nivel basado en XP (ejemplo simple)
        nuevo_nivel = (perfil_estudiante.total_xp // 100) + 1
        perfil_estudiante.nivel_usuario = nuevo_nivel
        
        db.session.commit()
        
        return jsonify({
            "mensaje": "XP actualizado correctamente",
            "total_xp": perfil_estudiante.total_xp,
            "nivel_usuario": perfil_estudiante.nivel_usuario,
            "xp_ganado": xp_ganado
        }), 200
        
    except (ValueError, TypeError):
        return jsonify({"error": "Token inv√°lido"}), 400
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error al actualizar XP: {e}")
        return jsonify({"error": "Error al actualizar XP"}), 500


# ========================================
# ACTUALIZAR RACHA DEL ESTUDIANTE
# ========================================
@usuario_bp.route("/actualizar-racha", methods=["PATCH"])
@jwt_required()
def actualizar_racha():
    """
    Actualiza la racha de d√≠as consecutivos del estudiante.
    """
    try:
        identity = get_jwt_identity()
        usuario_id = int(identity)
        
        from datetime import date
        
        usuario = Usuario.query.get(usuario_id)
        if not usuario or usuario.rol != 'alumno':
            return jsonify({"error": "Solo estudiantes tienen racha"}), 403
        
        perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
        if not perfil_estudiante:
            return jsonify({"error": "Perfil de estudiante no encontrado"}), 404
        
        hoy = date.today()
        ultima_actividad = perfil_estudiante.ultima_actividad
        
        # L√≥gica de racha
        if ultima_actividad is None:
            # Primera actividad
            perfil_estudiante.dias_racha = 1
        elif ultima_actividad == hoy:
            # Ya se registr√≥ actividad hoy
            pass
        elif (hoy - ultima_actividad).days == 1:
            # D√≠a consecutivo
            perfil_estudiante.dias_racha += 1
        else:
            # Se rompi√≥ la racha
            perfil_estudiante.dias_racha = 1
        
        # Actualizar racha m√°xima
        if perfil_estudiante.dias_racha > perfil_estudiante.racha_maxima:
            perfil_estudiante.racha_maxima = perfil_estudiante.dias_racha
        
        perfil_estudiante.ultima_actividad = hoy
        db.session.commit()
        
        return jsonify({
            "mensaje": "Racha actualizada",
            "dias_racha": perfil_estudiante.dias_racha,
            "racha_maxima": perfil_estudiante.racha_maxima
        }), 200
        
    except (ValueError, TypeError):
        return jsonify({"error": "Token inv√°lido"}), 400
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error al actualizar racha: {e}")
        return jsonify({"error": "Error al actualizar racha"}), 500


================================================================================
# ARCHIVO: back-end/services/correo_service.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/correo_service.py
================================================================================

from flask_mail import Message
from extensions import mail

def enviar_codigo_verificacion(correo, codigo):
    """Env√≠a el c√≥digo de verificaci√≥n al correo del usuario"""
    try:
        msg = Message(
            subject="Verifica tu cuenta en SpeakLexi",
            recipients=[correo],
            body=f"""
            ¬°Bienvenido a SpeakLexi!
            
            Tu c√≥digo de verificaci√≥n es: {codigo}
            
            Este c√≥digo expirar√° en 24 horas.
            
            Si no solicitaste esta verificaci√≥n, ignora este mensaje.
            
            Saludos,
            Equipo SpeakLexi
            """,
            html=f"""
            <html>
                <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px; text-align: center;">
                        <h1 style="color: white; margin: 0;">¬°Bienvenido a SpeakLexi!</h1>
                    </div>
                    
                    <div style="padding: 30px; background-color: #f9f9f9; border-radius: 10px; margin-top: 20px;">
                        <p style="font-size: 16px; color: #333;">Tu c√≥digo de verificaci√≥n es:</p>
                        <div style="background-color: white; padding: 20px; border-radius: 8px; text-align: center; margin: 20px 0;">
                            <h2 style="color: #667eea; letter-spacing: 5px; font-size: 32px; margin: 0;">{codigo}</h2>
                        </div>
                        <p style="font-size: 14px; color: #666;">Este c√≥digo expirar√° en <strong>24 horas</strong>.</p>
                        <p style="font-size: 14px; color: #666;">Si no solicitaste esta verificaci√≥n, ignora este mensaje.</p>
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <p style="font-size: 12px; color: #999;">Equipo SpeakLexi</p>
                    </div>
                </body>
            </html>
            """
        )
        mail.send(msg)
        print(f"‚úÖ C√≥digo de verificaci√≥n enviado a {correo}")
    except Exception as e:
        print(f"‚ùå Error al enviar correo de verificaci√≥n: {str(e)}")
        raise


def enviar_recuperacion_password(correo, token):
    """Env√≠a el enlace de recuperaci√≥n de contrase√±a con token seguro"""
    # URL del frontend (ajusta seg√∫n tu configuraci√≥n)
    FRONTEND_URL = "http://localhost:3000"
    enlace_recuperacion = f"{FRONTEND_URL}/restablecer-contrasena?token={token}"
    
    try:
        msg = Message(
            subject="Recuperaci√≥n de contrase√±a - SpeakLexi",
            recipients=[correo],
            body=f"""
            Solicitud de recuperaci√≥n de contrase√±a
            
            Haz clic en el siguiente enlace para restablecer tu contrase√±a:
            {enlace_recuperacion}
            
            Este enlace expirar√° en 1 hora.
            
            Si no solicitaste restablecer tu contrase√±a, ignora este mensaje.
            Tu contrase√±a permanecer√° sin cambios.
            
            Saludos,
            Equipo SpeakLexi
            """,
            html=f"""
            <html>
                <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px; text-align: center;">
                        <h1 style="color: white; margin: 0;">Recuperaci√≥n de Contrase√±a</h1>
                    </div>
                    
                    <div style="padding: 30px; background-color: #f9f9f9; border-radius: 10px; margin-top: 20px;">
                        <p style="font-size: 16px; color: #333;">Recibimos una solicitud para restablecer tu contrase√±a.</p>
                        <p style="font-size: 16px; color: #333;">Haz clic en el siguiente bot√≥n para continuar:</p>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="{enlace_recuperacion}" 
                               style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                      color: white; 
                                      padding: 15px 40px; 
                                      text-decoration: none; 
                                      border-radius: 8px; 
                                      font-size: 16px; 
                                      font-weight: bold;
                                      display: inline-block;">
                                Restablecer Contrase√±a
                            </a>
                        </div>
                        
                        <p style="font-size: 14px; color: #666;">O copia y pega este enlace en tu navegador:</p>
                        <p style="font-size: 12px; color: #999; word-break: break-all; background-color: white; padding: 10px; border-radius: 4px;">
                            {enlace_recuperacion}
                        </p>
                        
                        <p style="font-size: 14px; color: #666; margin-top: 20px;">Este enlace expirar√° en <strong>1 hora</strong>.</p>
                        
                        <div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 20px 0; border-radius: 4px;">
                            <p style="font-size: 14px; color: #856404; margin: 0;">
                                <strong>‚ö†Ô∏è Importante:</strong> Si no solicitaste restablecer tu contrase√±a, 
                                ignora este mensaje. Tu contrase√±a permanecer√° sin cambios.
                            </p>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <p style="font-size: 12px; color: #999;">Equipo SpeakLexi</p>
                        <p style="font-size: 11px; color: #ccc; margin-top: 10px;">
                            Este correo fue enviado a {correo}
                        </p>
                    </div>
                </body>
            </html>
            """
        )
        mail.send(msg)
        print(f"‚úÖ Correo de recuperaci√≥n enviado a {correo}")
    except Exception as e:
        print(f"‚ùå Error al enviar correo de recuperaci√≥n: {str(e)}")
        raise


================================================================================
# ARCHIVO: back-end/services/gestor_cursos.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_cursos.py
================================================================================

# back-end/services/gestor_cursos.py
"""
Servicio para gesti√≥n de cursos y progreso de estudiantes
Maneja la l√≥gica de negocio relacionada con cursos, inscripciones y seguimiento
"""

from models.cursos import Curso, ProgresoCurso
from models.usuario import Usuario, PerfilEstudiante
from models.leccion import Leccion
from extensions import db
from sqlalchemy import func, desc, and_, or_
from datetime import date, datetime
import logging

logger = logging.getLogger(__name__)


class GestorCursos:
    """Gestor principal de cursos del sistema"""
    
    @staticmethod
    def crear_curso(datos, usuario_creador_id):
        """
        Crear un nuevo curso
        
        Args:
            datos (dict): Datos del curso
            usuario_creador_id (int): ID del usuario que crea el curso
            
        Returns:
            tuple: (curso, error_msg)
        """
        try:
            # Validar campos requeridos
            campos_requeridos = ['nombre', 'nivel', 'idioma', 'codigo']
            for campo in campos_requeridos:
                if campo not in datos or not datos[campo]:
                    return None, f'Campo requerido faltante: {campo}'
            
            # Validar que el c√≥digo no exista
            if Curso.query.filter_by(codigo=datos['codigo'].upper()).first():
                return None, 'El c√≥digo de curso ya existe'
            
            # Validar nivel CEFR
            niveles_validos = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']
            if datos['nivel'].upper() not in niveles_validos:
                return None, f'Nivel inv√°lido. Use: {", ".join(niveles_validos)}'
            
            # Validar usuario creador
            usuario = Usuario.query.get(usuario_creador_id)
            if not usuario or usuario.rol not in ['admin', 'profesor']:
                return None, 'No autorizado para crear cursos'
            
            # Si es profesor, asignarlo autom√°ticamente
            profesor_id = datos.get('profesor_id')
            if usuario.rol == 'profesor':
                profesor_id = usuario_creador_id
            
            # Crear curso
            nuevo_curso = Curso(
                nombre=datos['nombre'].strip(),
                nivel=datos['nivel'].upper(),
                descripcion=datos.get('descripcion', '').strip(),
                idioma=datos.get('idioma', 'ingles'),
                codigo=datos['codigo'].upper().strip(),
                profesor_id=profesor_id,
                imagen_portada=datos.get('imagen_portada'),
                orden=datos.get('orden', 0),
                activo=datos.get('activo', True),
                requisitos_previos=datos.get('requisitos_previos'),
                objetivos_aprendizaje=datos.get('objetivos_aprendizaje')
            )
            
            db.session.add(nuevo_curso)
            db.session.commit()
            
            logger.info(f"Curso creado: {nuevo_curso.codigo} por usuario {usuario_creador_id}")
            return nuevo_curso, None
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error al crear curso: {str(e)}")
            return None, f'Error al crear curso: {str(e)}'
    
    @staticmethod
    def actualizar_curso(curso_id, datos, usuario_id):
        """
        Actualizar datos de un curso existente
        
        Args:
            curso_id (int): ID del curso
            datos (dict): Datos a actualizar
            usuario_id (int): ID del usuario que actualiza
            
        Returns:
            tuple: (curso, error_msg)
        """
        try:
            curso = Curso.query.get(curso_id)
            if not curso:
                return None, 'Curso no encontrado'
            
            # Verificar permisos
            usuario = Usuario.query.get(usuario_id)
            if usuario.rol == 'profesor' and curso.profesor_id != usuario_id:
                return None, 'No tienes permiso para editar este curso'
            
            if usuario.rol not in ['admin', 'profesor']:
                return None, 'No autorizado'
            
            # Campos actualizables
            campos_permitidos = [
                'nombre', 'descripcion', 'profesor_id', 'imagen_portada',
                'activo', 'requisitos_previos', 'objetivos_aprendizaje', 'orden'
            ]
            
            for campo in campos_permitidos:
                if campo in datos:
                    valor = datos[campo]
                    if isinstance(valor, str):
                        valor = valor.strip()
                    setattr(curso, campo, valor)
            
            curso.actualizado_en = datetime.utcnow()
            db.session.commit()
            
            logger.info(f"Curso actualizado: {curso.codigo}")
            return curso, None
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error al actualizar curso: {str(e)}")
            return None, str(e)
    
    @staticmethod
    def eliminar_curso(curso_id, usuario_id):
        """
        Eliminar un curso (solo si no tiene lecciones)
        
        Args:
            curso_id (int): ID del curso
            usuario_id (int): ID del administrador
            
        Returns:
            tuple: (exito, error_msg)
        """
        try:
            usuario = Usuario.query.get(usuario_id)
            if usuario.rol != 'admin':
                return False, 'Solo administradores pueden eliminar cursos'
            
            curso = Curso.query.get(curso_id)
            if not curso:
                return False, 'Curso no encontrado'
            
            # Verificar que no tenga lecciones
            if curso.total_lecciones > 0:
                return False, 'No se puede eliminar un curso con lecciones. Elimine las lecciones primero.'
            
            # Verificar estudiantes inscritos
            estudiantes = ProgresoCurso.query.filter_by(curso_id=curso_id).count()
            if estudiantes > 0:
                return False, f'Hay {estudiantes} estudiante(s) inscrito(s). No se puede eliminar.'
            
            codigo = curso.codigo
            db.session.delete(curso)
            db.session.commit()
            
            logger.info(f"Curso eliminado: {codigo}")
            return True, None
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error al eliminar curso: {str(e)}")
            return False, str(e)
    
    @staticmethod
    def obtener_cursos_disponibles(idioma='ingles', nivel=None, solo_activos=True):
        """
        Obtener lista de cursos disponibles
        
        Args:
            idioma (str): Filtrar por idioma
            nivel (str): Filtrar por nivel CEFR
            solo_activos (bool): Solo cursos activos
            
        Returns:
            list: Lista de cursos
        """
        try:
            query = Curso.query
            
            if solo_activos:
                query = query.filter_by(activo=True)
            
            query = query.filter_by(idioma=idioma)
            
            if nivel:
                query = query.filter_by(nivel=nivel.upper())
            
            cursos = query.order_by(Curso.orden, Curso.nivel).all()
            return cursos
            
        except Exception as e:
            logger.error(f"Error al obtener cursos: {str(e)}")
            return []
    
    @staticmethod
    def inscribir_estudiante(usuario_id, curso_id):
        """
        Inscribir un estudiante en un curso
        
        Args:
            usuario_id (int): ID del estudiante
            curso_id (int): ID del curso
            
        Returns:
            tuple: (progreso, error_msg)
        """
        try:
            # Validar estudiante
            usuario = Usuario.query.get(usuario_id)
            if not usuario or usuario.rol != 'alumno':
                return None, 'Usuario no v√°lido o no es estudiante'
            
            # Validar curso
            curso = Curso.query.get(curso_id)
            if not curso:
                return None, 'Curso no encontrado'
            
            if not curso.activo:
                return None, 'El curso no est√° disponible actualmente'
            
            # Verificar si ya est√° inscrito
            progreso_existente = ProgresoCurso.query.filter_by(
                usuario_id=usuario_id,
                curso_id=curso_id
            ).first()
            
            if progreso_existente:
                return None, 'Ya est√°s inscrito en este curso'
            
            # Verificar prerequisitos
            if not curso.tiene_prerequisitos_cumplidos(usuario_id):
                return None, 'No cumples con los prerequisitos requeridos'
            
            # Crear registro de progreso
            nuevo_progreso = ProgresoCurso(
                usuario_id=usuario_id,
                curso_id=curso_id,
                lecciones_totales=curso.total_lecciones,
                fecha_inicio=date.today(),
                estado='en_progreso' if curso.total_lecciones > 0 else 'no_iniciado'
            )
            
            db.session.add(nuevo_progreso)
            
            # Actualizar perfil del estudiante
            perfil = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
            if perfil:
                perfil.curso_actual_id = curso_id
                perfil.nivel_asignado = curso.nivel
            
            db.session.commit()
            
            logger.info(f"Estudiante {usuario_id} inscrito en curso {curso_id}")
            return nuevo_progreso, None
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error al inscribir estudiante: {str(e)}")
            return None, str(e)
    
    @staticmethod
    def obtener_progreso_estudiante(usuario_id, curso_id):
        """
        Obtener o crear el progreso de un estudiante en un curso
        
        Args:
            usuario_id (int): ID del estudiante
            curso_id (int): ID del curso
            
        Returns:
            ProgresoCurso: Objeto de progreso
        """
        try:
            progreso = ProgresoCurso.query.filter_by(
                usuario_id=usuario_id,
                curso_id=curso_id
            ).first()
            
            if not progreso:
                # Crear progreso inicial
                curso = Curso.query.get(curso_id)
                if curso:
                    progreso = ProgresoCurso(
                        usuario_id=usuario_id,
                        curso_id=curso_id,
                        lecciones_totales=curso.total_lecciones
                    )
                    db.session.add(progreso)
                    db.session.commit()
            
            return progreso
            
        except Exception as e:
            logger.error(f"Error al obtener progreso: {str(e)}")
            return None
    
    @staticmethod
    def registrar_leccion_completada(usuario_id, curso_id, leccion_id, 
                                     tiempo_minutos=0, puntuacion=None):
        """
        Registrar la finalizaci√≥n de una lecci√≥n
        
        Args:
            usuario_id (int): ID del estudiante
            curso_id (int): ID del curso
            leccion_id (int): ID de la lecci√≥n
            tiempo_minutos (int): Tiempo dedicado en minutos
            puntuacion (float): Puntuaci√≥n obtenida
            
        Returns:
            tuple: (progreso, error_msg)
        """
        try:
            # Obtener o crear progreso
            progreso = GestorCursos.obtener_progreso_estudiante(usuario_id, curso_id)
            if not progreso:
                return None, 'No se pudo obtener el progreso'
            
            # Verificar que la lecci√≥n pertenece al curso
            leccion = Leccion.query.get(leccion_id)
            if not leccion or leccion.curso_id != curso_id:
                return None, 'Lecci√≥n no v√°lida para este curso'
            
            # Registrar progreso
            progreso.registrar_leccion_completada(leccion_id, tiempo_minutos, puntuacion)
            
            # Actualizar perfil del estudiante
            perfil = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
            if perfil:
                perfil.lecciones_completadas += 1
                perfil.tiempo_estudio_total += tiempo_minutos
                perfil.ultima_actividad = date.today()
                
                # Actualizar racha
                if perfil.ultima_actividad != date.today():
                    perfil.dias_racha += 1
                    if perfil.dias_racha > perfil.racha_maxima:
                        perfil.racha_maxima = perfil.dias_racha
            
            db.session.commit()
            
            logger.info(f"Lecci√≥n {leccion_id} completada por usuario {usuario_id}")
            return progreso, None
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error al registrar lecci√≥n: {str(e)}")
            return None, str(e)
    
    @staticmethod
    def obtener_estadisticas_curso(curso_id):
        """
        Obtener estad√≠sticas completas de un curso
        
        Args:
            curso_id (int): ID del curso
            
        Returns:
            dict: Estad√≠sticas del curso
        """
        try:
            curso = Curso.query.get(curso_id)
            if not curso:
                return None
            
            # Contar estudiantes por estado
            total_estudiantes = ProgresoCurso.query.filter_by(curso_id=curso_id).count()
            completados = ProgresoCurso.query.filter_by(
                curso_id=curso_id, estado='completado'
            ).count()
            en_progreso = ProgresoCurso.query.filter_by(
                curso_id=curso_id, estado='en_progreso'
            ).count()
            
            # Calcular promedios
            progresos = ProgresoCurso.query.filter_by(curso_id=curso_id).all()
            
            if progresos:
                promedio_progreso = sum(float(p.porcentaje_completado or 0) for p in progresos) / len(progresos)
                puntuaciones = [float(p.puntuacion_promedio) for p in progresos if p.puntuacion_promedio]
                promedio_puntuacion = sum(puntuaciones) / len(puntuaciones) if puntuaciones else None
                tiempos = [p.tiempo_dedicado for p in progresos if p.tiempo_dedicado]
                tiempo_promedio = sum(tiempos) / len(tiempos) if tiempos else 0
            else:
                promedio_progreso = 0
                promedio_puntuacion = None
                tiempo_promedio = 0
            
            estadisticas = {
                'curso_id': curso_id,
                'curso_nombre': curso.nombre,
                'nivel': curso.nivel,
                'total_lecciones': curso.total_lecciones,
                'duracion_estimada': curso.duracion_estimada_total,
                'estudiantes': {
                    'total': total_estudiantes,
                    'completado': completados,
                    'en_progreso': en_progreso,
                    'no_iniciado': total_estudiantes - completados - en_progreso
                },
                'promedios': {
                    'progreso': round(promedio_progreso, 2),
                    'puntuacion': round(promedio_puntuacion, 2) if promedio_puntuacion else None,
                    'tiempo_dedicado': round(tiempo_promedio, 2)
                },
                'tasa_completado': round((completados / total_estudiantes * 100), 2) if total_estudiantes > 0 else 0
            }
            
            return estadisticas
            
        except Exception as e:
            logger.error(f"Error al obtener estad√≠sticas: {str(e)}")
            return None
    
    @staticmethod
    def obtener_cursos_estudiante(usuario_id, incluir_progreso=True):
        """
        Obtener todos los cursos de un estudiante
        
        Args:
            usuario_id (int): ID del estudiante
            incluir_progreso (bool): Incluir datos de progreso
            
        Returns:
            list: Lista de cursos con progreso
        """
        try:
            progresos = ProgresoCurso.query.filter_by(usuario_id=usuario_id).all()
            
            if not incluir_progreso:
                return [p.curso for p in progresos]
            
            cursos_data = []
            for progreso in progresos:
                curso_dict = progreso.curso.to_dict(incluir_lecciones=False)
                curso_dict['progreso'] = {
                    'lecciones_completadas': progreso.lecciones_completadas,
                    'lecciones_totales': progreso.lecciones_totales,
                    'porcentaje': float(progreso.porcentaje_completado or 0),
                    'estado': progreso.estado,
                    'tiempo_dedicado': progreso.tiempo_dedicado,
                    'puntuacion_promedio': float(progreso.puntuacion_promedio) if progreso.puntuacion_promedio else None,
                    'ultima_leccion_id': progreso.ultima_leccion_id,
                    'fecha_inicio': progreso.fecha_inicio.isoformat() if progreso.fecha_inicio else None
                }
                cursos_data.append(curso_dict)
            
            return cursos_data
            
        except Exception as e:
            logger.error(f"Error al obtener cursos del estudiante: {str(e)}")
            return []
    
    @staticmethod
    def obtener_cursos_profesor(profesor_id):
        """
        Obtener cursos asignados a un profesor
        
        Args:
            profesor_id (int): ID del profesor
            
        Returns:
            list: Lista de cursos
        """
        try:
            cursos = Curso.query.filter_by(profesor_id=profesor_id).order_by(Curso.orden).all()
            return cursos
            
        except Exception as e:
            logger.error(f"Error al obtener cursos del profesor: {str(e)}")
            return []
    
    @staticmethod
    def cambiar_estado_curso(curso_id, activo):
        """
        Activar o desactivar un curso
        
        Args:
            curso_id (int): ID del curso
            activo (bool): Nuevo estado
            
        Returns:
            tuple: (curso, error_msg)
        """
        try:
            curso = Curso.query.get(curso_id)
            if not curso:
                return None, 'Curso no encontrado'
            
            curso.activo = activo
            db.session.commit()
            
            logger.info(f"Curso {curso.codigo} {'activado' if activo else 'desactivado'}")
            return curso, None
            
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error al cambiar estado del curso: {str(e)}")
            return None, str(e)
    
    @staticmethod
    def obtener_siguiente_leccion(usuario_id, curso_id):
        """
        Obtener la siguiente lecci√≥n que debe tomar el estudiante
        
        Args:
            usuario_id (int): ID del estudiante
            curso_id (int): ID del curso
            
        Returns:
            Leccion: Siguiente lecci√≥n o None
        """
        try:
            progreso = ProgresoCurso.query.filter_by(
                usuario_id=usuario_id,
                curso_id=curso_id
            ).first()
            
            if not progreso or not progreso.ultima_leccion_id:
                # Primera lecci√≥n del curso
                return Leccion.query.filter_by(
                    curso_id=curso_id,
                    estado='publicada'
                ).order_by(Leccion.orden).first()
            
            # Siguiente lecci√≥n despu√©s de la √∫ltima completada
            ultima_leccion = Leccion.query.get(progreso.ultima_leccion_id)
            if ultima_leccion:
                siguiente = Leccion.query.filter(
                    Leccion.curso_id == curso_id,
                    Leccion.estado == 'publicada',
                    Leccion.orden > ultima_leccion.orden
                ).order_by(Leccion.orden).first()
                
                return siguiente
            
            return None
            
        except Exception as e:
            logger.error(f"Error al obtener siguiente lecci√≥n: {str(e)}")
            return None
    
    @staticmethod
    def validar_prerequisitos(usuario_id, curso_id):
        """
        Validar si un estudiante cumple los prerequisitos de un curso
        
        Args:
            usuario_id (int): ID del estudiante
            curso_id (int): ID del curso
            
        Returns:
            tuple: (cumple, cursos_faltantes)
        """
        try:
            curso = Curso.query.get(curso_id)
            if not curso or not curso.requisitos_previos:
                return True, []
            
            cursos_faltantes = []
            
            for curso_req_id in curso.requisitos_previos:
                progreso = ProgresoCurso.query.filter_by(
                    usuario_id=usuario_id,
                    curso_id=curso_req_id
                ).first()
                
                if not progreso or progreso.estado != 'completado':
                    curso_req = Curso.query.get(curso_req_id)
                    if curso_req:
                        cursos_faltantes.append(curso_req.to_dict(incluir_lecciones=False))
            
            return len(cursos_faltantes) == 0, cursos_faltantes
            
        except Exception as e:
            logger.error(f"Error al validar prerequisitos: {str(e)}")
            return False, []


# Funciones auxiliares

def calcular_nivel_sugerido(puntuacion_prueba):
    """
    Calcular nivel CEFR sugerido basado en puntuaci√≥n de prueba
    
    Args:
        puntuacion_prueba (int): Puntuaci√≥n de 0-100
        
    Returns:
        str: Nivel CEFR sugerido
    """
    if puntuacion_prueba < 20:
        return 'A1'
    elif puntuacion_prueba < 40:
        return 'A2'
    elif puntuacion_prueba < 60:
        return 'B1'
    elif puntuacion_prueba < 75:
        return 'B2'
    elif puntuacion_prueba < 90:
        return 'C1'
    else:
        return 'C2'


def obtener_curso_por_nivel(nivel, idioma='ingles'):
    """
    Obtener el curso correspondiente a un nivel
    
    Args:
        nivel (str): Nivel CEFR
        idioma (str): Idioma del curso
        
    Returns:
        Curso: Curso correspondiente o None
    """
    return Curso.query.filter_by(
        nivel=nivel.upper(),
        idioma=idioma,
        activo=True
    ).first()


================================================================================
# ARCHIVO: back-end/services/gestor_lecciones.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_lecciones.py
================================================================================

"""
Gestor de Lecciones - SpeakLexi
Maneja toda la l√≥gica de negocio relacionada con lecciones y actividades
"""

from config.database import db
from models.leccion import (
    Leccion, Actividad, NivelDificultad, 
    TipoActividad, EstadoLeccion
)
from models.multimedia import Multimedia
from sqlalchemy.exc import IntegrityError
from sqlalchemy import or_, and_
from datetime import datetime


class GestorLecciones:
    """Gestiona operaciones CRUD y l√≥gica de negocio de lecciones"""
    
    @staticmethod
    def _obtener_nivel_enum(nivel_str):
        """
        Convierte un string a enum NivelDificultad.
        Acepta valores en may√∫sculas o min√∫sculas.
        """
        if isinstance(nivel_str, NivelDificultad):
            return nivel_str
            
        nivel_str = str(nivel_str).lower().strip()
        
        # Mapeo de valores string a enum
        mapeo_niveles = {
            'principiante': NivelDificultad.PRINCIPIANTE,
            'intermedio': NivelDificultad.INTERMEDIO,
            'avanzado': NivelDificultad.AVANZADO
        }
        
        if nivel_str not in mapeo_niveles:
            raise ValueError(f"Nivel inv√°lido. Valores permitidos: {list(mapeo_niveles.keys())}")
        
        return mapeo_niveles[nivel_str]
    
    @staticmethod
    def _obtener_estado_enum(estado_str):
        """
        Convierte un string a enum EstadoLeccion.
        """
        if isinstance(estado_str, EstadoLeccion):
            return estado_str
            
        estado_str = str(estado_str).lower().strip()
        
        mapeo_estados = {
            'borrador': EstadoLeccion.BORRADOR,
            'publicada': EstadoLeccion.PUBLICADA,
            'archivada': EstadoLeccion.ARCHIVADA
        }
        
        if estado_str not in mapeo_estados:
            raise ValueError(f"Estado inv√°lido. Valores permitidos: {list(mapeo_estados.keys())}")
        
        return mapeo_estados[estado_str]
    
    @staticmethod
    def _obtener_tipo_actividad_enum(tipo_str):
        """
        Convierte un string a enum TipoActividad.
        """
        if isinstance(tipo_str, TipoActividad):
            return tipo_str
            
        tipo_str = str(tipo_str).lower().strip()
        
        mapeo_tipos = {
            'multiple_choice': TipoActividad.MULTIPLE_CHOICE,
            'fill_blank': TipoActividad.FILL_BLANK,
            'matching': TipoActividad.MATCHING,
            'translation': TipoActividad.TRANSLATION,
            'listen_repeat': TipoActividad.LISTEN_REPEAT,
            'true_false': TipoActividad.TRUE_FALSE,
            'word_order': TipoActividad.WORD_ORDER
        }
        
        if tipo_str not in mapeo_tipos:
            raise ValueError(f"Tipo inv√°lido. Valores permitidos: {list(mapeo_tipos.keys())}")
        
        return mapeo_tipos[tipo_str]
    
    def crear_leccion(self, datos_leccion, usuario_id):
        """
        Crea una nueva lecci√≥n en el sistema.
        
        Args:
            datos_leccion (dict): Datos de la lecci√≥n
            usuario_id (int): ID del usuario que crea la lecci√≥n
        
        Returns:
            tuple: (dict con lecci√≥n creada, c√≥digo HTTP)
        """
        try:
            # Validar datos obligatorios
            if not datos_leccion.get('titulo'):
                return {"error": "El t√≠tulo es obligatorio"}, 400
            
            if not datos_leccion.get('contenido'):
                return {"error": "El contenido es obligatorio"}, 400
            
            # Validar y convertir nivel
            nivel_str = datos_leccion.get('nivel', 'principiante')
            try:
                nivel = self._obtener_nivel_enum(nivel_str)
            except ValueError as e:
                return {"error": str(e)}, 400
            
            # Crear nueva lecci√≥n
            nueva_leccion = Leccion(
                titulo=datos_leccion['titulo'],
                descripcion=datos_leccion.get('descripcion', ''),
                contenido=datos_leccion['contenido'],
                nivel=nivel,
                idioma=datos_leccion.get('idioma', 'ingles'),
                categoria=datos_leccion.get('categoria'),
                etiquetas=datos_leccion.get('etiquetas', []),
                orden=datos_leccion.get('orden'),
                requisitos=datos_leccion.get('requisitos', []),
                duracion_estimada=datos_leccion.get('duracion_estimada', 10),
                puntos_xp=datos_leccion.get('puntos_xp', 50),
                estado=EstadoLeccion.BORRADOR,
                creado_por=usuario_id
            )
            
            db.session.add(nueva_leccion)
            db.session.commit()
            
            return {
                "mensaje": "Lecci√≥n creada exitosamente",
                "leccion": nueva_leccion.to_dict()
            }, 201
            
        except IntegrityError as e:
            db.session.rollback()
            return {"error": f"Error de integridad: {str(e)}"}, 500
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al crear lecci√≥n: {str(e)}"}, 500
    
    def obtener_leccion(self, leccion_id, incluir_actividades=False, incluir_multimedia=False):
        """
        Obtiene una lecci√≥n por su ID.
        
        Args:
            leccion_id (int): ID de la lecci√≥n
            incluir_actividades (bool): Si incluir actividades
            incluir_multimedia (bool): Si incluir recursos multimedia
        
        Returns:
            tuple: (dict con lecci√≥n o error, c√≥digo HTTP)
        """
        leccion = Leccion.query.get(leccion_id)
        
        if not leccion:
            return {"error": "Lecci√≥n no encontrada"}, 404
        
        return {
            "leccion": leccion.to_dict(
                incluir_actividades=incluir_actividades,
                incluir_multimedia=incluir_multimedia
            )
        }, 200
    
    def listar_lecciones(self, filtros=None, pagina=1, por_pagina=20):
        """
        Lista lecciones con filtros opcionales y paginaci√≥n.
        
        Args:
            filtros (dict): Filtros opcionales
            pagina (int): N√∫mero de p√°gina
            por_pagina (int): Lecciones por p√°gina
        
        Returns:
            tuple: (dict con lecciones paginadas, c√≥digo HTTP)
        """
        try:
            query = Leccion.query
            
            # Aplicar filtros si existen
            if filtros:
                if filtros.get('nivel'):
                    try:
                        nivel = self._obtener_nivel_enum(filtros['nivel'])
                        query = query.filter_by(nivel=nivel)
                    except ValueError:
                        pass  # Ignorar nivel inv√°lido
                
                if filtros.get('idioma'):
                    query = query.filter_by(idioma=filtros['idioma'])
                
                if filtros.get('categoria'):
                    query = query.filter_by(categoria=filtros['categoria'])
                
                if filtros.get('estado'):
                    try:
                        estado = self._obtener_estado_enum(filtros['estado'])
                        query = query.filter_by(estado=estado)
                    except ValueError:
                        pass  # Ignorar estado inv√°lido
                
                if filtros.get('buscar'):
                    termino = f"%{filtros['buscar']}%"
                    query = query.filter(
                        or_(
                            Leccion.titulo.ilike(termino),
                            Leccion.descripcion.ilike(termino)
                        )
                    )
                
                if filtros.get('etiqueta'):
                    query = query.filter(
                        Leccion.etiquetas.contains([filtros['etiqueta']])
                    )
            
            # Ordenar por orden y fecha de creaci√≥n
            query = query.order_by(Leccion.orden.asc(), Leccion.creado_en.desc())
            
            # Paginar resultados
            paginacion = query.paginate(
                page=pagina,
                per_page=por_pagina,
                error_out=False
            )
            
            return {
                "lecciones": [leccion.to_dict() for leccion in paginacion.items],
                "total": paginacion.total,
                "pagina": paginacion.page,
                "paginas_totales": paginacion.pages,
                "tiene_siguiente": paginacion.has_next,
                "tiene_anterior": paginacion.has_prev
            }, 200
            
        except Exception as e:
            return {"error": f"Error al listar lecciones: {str(e)}"}, 500
    
    def actualizar_leccion(self, leccion_id, datos_actualizados, usuario_id):
        """Actualiza una lecci√≥n existente."""
        try:
            leccion = Leccion.query.get(leccion_id)
            
            if not leccion:
                return {"error": "Lecci√≥n no encontrada"}, 404
            
            # Actualizar campos permitidos
            campos_editables = [
                'titulo', 'descripcion', 'contenido', 'categoria',
                'etiquetas', 'orden', 'requisitos', 'duracion_estimada',
                'puntos_xp', 'idioma'
            ]
            
            for campo in campos_editables:
                if campo in datos_actualizados:
                    setattr(leccion, campo, datos_actualizados[campo])
            
            # Manejar nivel especialmente
            if 'nivel' in datos_actualizados:
                try:
                    nivel = self._obtener_nivel_enum(datos_actualizados['nivel'])
                    leccion.nivel = nivel
                except ValueError as e:
                    return {"error": str(e)}, 400
            
            leccion.actualizado_en = datetime.utcnow()
            db.session.commit()
            
            return {
                "mensaje": "Lecci√≥n actualizada exitosamente",
                "leccion": leccion.to_dict()
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al actualizar lecci√≥n: {str(e)}"}, 500
    
    def eliminar_leccion(self, leccion_id, usuario_id):
        """Elimina una lecci√≥n (soft delete: archivar)."""
        try:
            leccion = Leccion.query.get(leccion_id)
            
            if not leccion:
                return {"error": "Lecci√≥n no encontrada"}, 404
            
            leccion.archivar()
            db.session.commit()
            
            return {
                "mensaje": "Lecci√≥n archivada exitosamente",
                "leccion_id": leccion_id
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al eliminar lecci√≥n: {str(e)}"}, 500
    
    def publicar_leccion(self, leccion_id, usuario_id):
        """Publica una lecci√≥n en borrador."""
        try:
            leccion = Leccion.query.get(leccion_id)
            
            if not leccion:
                return {"error": "Lecci√≥n no encontrada"}, 404
            
            if leccion.estado == EstadoLeccion.PUBLICADA:
                return {"mensaje": "La lecci√≥n ya est√° publicada"}, 200
            
            if leccion.actividades.count() == 0:
                return {
                    "error": "La lecci√≥n debe tener al menos una actividad para publicarse"
                }, 400
            
            leccion.publicar()
            db.session.commit()
            
            return {
                "mensaje": "Lecci√≥n publicada exitosamente",
                "leccion": leccion.to_dict()
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al publicar lecci√≥n: {str(e)}"}, 500
    
    # ========== GESTI√ìN DE ACTIVIDADES ==========
    
    def agregar_actividad(self, leccion_id, datos_actividad):
        """Agrega una actividad a una lecci√≥n."""
        try:
            leccion = Leccion.query.get(leccion_id)
            
            if not leccion:
                return {"error": "Lecci√≥n no encontrada"}, 404
            
            # Validar tipo de actividad
            try:
                tipo = self._obtener_tipo_actividad_enum(datos_actividad['tipo'])
            except ValueError as e:
                return {"error": str(e)}, 400
            
            # Determinar orden si no se especifica
            orden = datos_actividad.get('orden')
            if orden is None:
                max_orden = db.session.query(
                    db.func.max(Actividad.orden)
                ).filter_by(leccion_id=leccion_id).scalar()
                orden = (max_orden or 0) + 1
            
            # Crear actividad
            nueva_actividad = Actividad(
                leccion_id=leccion_id,
                tipo=tipo,
                pregunta=datos_actividad['pregunta'],
                instrucciones=datos_actividad.get('instrucciones'),
                opciones=datos_actividad.get('opciones', {}),
                respuesta_correcta=datos_actividad['respuesta_correcta'],
                retroalimentacion=datos_actividad.get('retroalimentacion', {}),
                pista=datos_actividad.get('pista'),
                puntos=datos_actividad.get('puntos', 10),
                orden=orden,
                tiempo_limite=datos_actividad.get('tiempo_limite'),
                multimedia_id=datos_actividad.get('multimedia_id')
            )
            
            db.session.add(nueva_actividad)
            db.session.commit()
            
            return {
                "mensaje": "Actividad agregada exitosamente",
                "actividad": nueva_actividad.to_dict()
            }, 201
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al agregar actividad: {str(e)}"}, 500
    
    def actualizar_actividad(self, actividad_id, datos_actualizados):
        """Actualiza una actividad existente."""
        try:
            actividad = Actividad.query.get(actividad_id)
            
            if not actividad:
                return {"error": "Actividad no encontrada"}, 404
            
            # Actualizar campos permitidos
            campos_editables = [
                'pregunta', 'instrucciones', 'opciones', 'respuesta_correcta',
                'retroalimentacion', 'pista', 'puntos', 'orden',
                'tiempo_limite', 'multimedia_id'
            ]
            
            for campo in campos_editables:
                if campo in datos_actualizados:
                    setattr(actividad, campo, datos_actualizados[campo])
            
            # Manejar tipo especialmente
            if 'tipo' in datos_actualizados:
                try:
                    tipo = self._obtener_tipo_actividad_enum(datos_actualizados['tipo'])
                    actividad.tipo = tipo
                except ValueError as e:
                    return {"error": str(e)}, 400
            
            actividad.actualizado_en = datetime.utcnow()
            db.session.commit()
            
            return {
                "mensaje": "Actividad actualizada exitosamente",
                "actividad": actividad.to_dict()
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al actualizar actividad: {str(e)}"}, 500
    
    def eliminar_actividad(self, actividad_id):
        """Elimina una actividad."""
        try:
            actividad = Actividad.query.get(actividad_id)
            
            if not actividad:
                return {"error": "Actividad no encontrada"}, 404
            
            leccion_id = actividad.leccion_id
            
            db.session.delete(actividad)
            db.session.commit()
            
            return {
                "mensaje": "Actividad eliminada exitosamente",
                "actividad_id": actividad_id,
                "leccion_id": leccion_id
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al eliminar actividad: {str(e)}"}, 500
    
    def verificar_respuesta_actividad(self, actividad_id, respuesta_usuario):
        """Verifica la respuesta de un usuario a una actividad."""
        try:
            actividad = Actividad.query.get(actividad_id)
            
            if not actividad:
                return {"error": "Actividad no encontrada"}, 404
            
            resultado = actividad.verificar_respuesta(respuesta_usuario)
            
            return {
                "actividad_id": actividad_id,
                **resultado
            }, 200
            
        except Exception as e:
            return {"error": f"Error al verificar respuesta: {str(e)}"}, 500
    
    # ========== ESTAD√çSTICAS Y UTILIDADES ==========
    
    def obtener_estadisticas_leccion(self, leccion_id):
        """Obtiene estad√≠sticas de una lecci√≥n."""
        try:
            leccion = Leccion.query.get(leccion_id)
            
            if not leccion:
                return {"error": "Lecci√≥n no encontrada"}, 404
            
            total_actividades = leccion.actividades.count()
            total_puntos = db.session.query(
                db.func.sum(Actividad.puntos)
            ).filter_by(leccion_id=leccion_id).scalar() or 0
            
            return {
                "leccion_id": leccion_id,
                "titulo": leccion.titulo,
                "total_actividades": total_actividades,
                "total_puntos": total_puntos,
                "duracion_estimada": leccion.duracion_estimada,
                "estado": leccion.estado.value,
                "recursos_multimedia": len(leccion.recursos_multimedia)
            }, 200
            
        except Exception as e:
            return {"error": f"Error al obtener estad√≠sticas: {str(e)}"}, 500
    
    def obtener_lecciones_por_nivel(self, nivel, idioma=None):
        """Obtiene lecciones filtradas por nivel y opcionalmente idioma."""
        try:
            try:
                nivel_enum = self._obtener_nivel_enum(nivel)
            except ValueError as e:
                return {"error": str(e)}, 400
            
            query = Leccion.query.filter_by(
                nivel=nivel_enum,
                estado=EstadoLeccion.PUBLICADA
            )
            
            if idioma:
                query = query.filter_by(idioma=idioma)
            
            lecciones = query.order_by(Leccion.orden.asc()).all()
            
            return {
                "nivel": nivel,
                "idioma": idioma,
                "total": len(lecciones),
                "lecciones": [leccion.to_dict() for leccion in lecciones]
            }, 200
            
        except Exception as e:
            return {"error": f"Error al obtener lecciones: {str(e)}"}, 500


# Instancia global del gestor
gestor_lecciones = GestorLecciones()


================================================================================
# ARCHIVO: back-end/services/gestor_multimedia.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_multimedia.py
================================================================================

"""
Gestor de Multimedia - SpeakLexi
Maneja toda la l√≥gica de negocio relacionada con recursos multimedia
"""

from config.database import db
from models.multimedia import (
    Multimedia, TipoMultimedia, EstadoMultimedia,
    ConfiguracionMultimedia, CONFIGURACION_POR_DEFECTO
)
from models.leccion import Leccion
from sqlalchemy.exc import IntegrityError
from sqlalchemy import or_
from werkzeug.utils import secure_filename
from datetime import datetime
import os
import uuid
from pathlib import Path


class GestorMultimedia:
    """Gestiona operaciones CRUD y procesamiento de archivos multimedia"""
    
    def __init__(self):
        """Inicializa el gestor con configuraciones por defecto"""
        self._configuracion_inicializada = False
    
    def _asegurar_configuracion(self):
        """Inicializa la configuraci√≥n solo cuando se necesita (lazy initialization)"""
        if not self._configuracion_inicializada:
            self._inicializar_configuracion()
            self._configuracion_inicializada = True
    
    def _inicializar_configuracion(self):
        """Carga configuraci√≥n o crea valores por defecto"""
        for clave, valor in CONFIGURACION_POR_DEFECTO.items():
            config = ConfiguracionMultimedia.query.filter_by(clave=clave).first()
            if not config:
                ConfiguracionMultimedia.establecer_valor(
                    clave, 
                    valor, 
                    f"Configuraci√≥n {clave}"
                )
    
    def subir_archivo(self, archivo, datos_adicionales, usuario_id):
        """
        Procesa y almacena un archivo multimedia.
        
        Args:
            archivo: Objeto de archivo (FileStorage de Flask)
            datos_adicionales (dict): Informaci√≥n adicional
                {
                    'descripcion': str,
                    'alt_text': str,
                    'categoria': str,
                    'etiquetas': list,
                    'transcripcion': str (opcional para audio/video)
                }
            usuario_id (int): ID del usuario que sube el archivo
        
        Returns:
            tuple: (dict con recurso creado, c√≥digo HTTP)
        """
        self._asegurar_configuracion()
        
        try:
            # Validar archivo
            if not archivo:
                return {"error": "No se proporcion√≥ ning√∫n archivo"}, 400
            
            nombre_original = secure_filename(archivo.filename)
            if not nombre_original:
                return {"error": "Nombre de archivo inv√°lido"}, 400
            
            # Detectar tipo MIME y tipo de recurso
            mime_type = archivo.content_type or 'application/octet-stream'
            tipo = self._detectar_tipo_multimedia(mime_type)
            
            if not tipo:
                return {
                    "error": f"Tipo de archivo no soportado: {mime_type}"
                }, 400
            
            # Validar tipo espec√≠fico
            if not Multimedia.validar_tipo_archivo(mime_type, tipo):
                return {
                    "error": f"El tipo MIME {mime_type} no coincide con el tipo {tipo.value}"
                }, 400
            
            # Validar tama√±o del archivo
            archivo.seek(0, os.SEEK_END)
            tamano = archivo.tell()
            archivo.seek(0)
            
            tamano_maximo = self._obtener_tamano_maximo(tipo)
            if tamano > tamano_maximo:
                tamano_mb = tamano / (1024 * 1024)
                max_mb = tamano_maximo / (1024 * 1024)
                return {
                    "error": f"Archivo muy grande ({tamano_mb:.2f} MB). M√°ximo: {max_mb:.2f} MB"
                }, 400
            
            # Generar nombre √∫nico
            nombre_almacenado = Multimedia.generar_nombre_unico(nombre_original)
            
            # Obtener ruta de almacenamiento
            ruta_base = ConfiguracionMultimedia.obtener_valor(
                'ruta_almacenamiento',
                'uploads/multimedia'
            )
            
            # Crear directorio si no existe
            ruta_completa = Path(ruta_base) / tipo.value
            ruta_completa.mkdir(parents=True, exist_ok=True)
            
            # Ruta del archivo
            ruta_archivo = ruta_completa / nombre_almacenado
            
            # Guardar archivo
            archivo.save(str(ruta_archivo))
            
            # Crear registro en base de datos
            nuevo_multimedia = Multimedia(
                nombre_archivo=nombre_original,
                nombre_almacenado=nombre_almacenado,
                tipo=tipo,
                mime_type=mime_type,
                categoria=datos_adicionales.get('categoria'),
                url=f"/{ruta_base}/{tipo.value}/{nombre_almacenado}",
                ruta_local=str(ruta_archivo),
                tamano=tamano,
                estado=EstadoMultimedia.DISPONIBLE,
                descripcion=datos_adicionales.get('descripcion'),
                alt_text=datos_adicionales.get('alt_text'),
                transcripcion=datos_adicionales.get('transcripcion'),
                etiquetas=datos_adicionales.get('etiquetas', []),
                meta_data={},
                subido_por=usuario_id
            )
            
            # Procesar metadata seg√∫n tipo
            if tipo == TipoMultimedia.IMAGEN:
                dimensiones = self._obtener_dimensiones_imagen(ruta_archivo)
                nuevo_multimedia.dimensiones = dimensiones
                
                # Generar thumbnail si est√° configurado
                if ConfiguracionMultimedia.obtener_valor('generar_thumbnails') == 'true':
                    url_thumb = self._generar_thumbnail(ruta_archivo, nombre_almacenado, tipo)
                    nuevo_multimedia.url_thumbnail = url_thumb
            
            elif tipo in [TipoMultimedia.AUDIO, TipoMultimedia.VIDEO]:
                duracion = self._obtener_duracion_media(ruta_archivo)
                nuevo_multimedia.duracion = duracion
                
                if tipo == TipoMultimedia.VIDEO:
                    dimensiones = self._obtener_dimensiones_video(ruta_archivo)
                    nuevo_multimedia.dimensiones = dimensiones
            
            db.session.add(nuevo_multimedia)
            db.session.commit()
            
            return {
                "mensaje": "Archivo subido exitosamente",
                "multimedia": nuevo_multimedia.to_dict()
            }, 201
            
        except Exception as e:
            db.session.rollback()
            # Limpiar archivo si existe
            if 'ruta_archivo' in locals() and Path(ruta_archivo).exists():
                Path(ruta_archivo).unlink()
            
            return {"error": f"Error al subir archivo: {str(e)}"}, 500
    
    def obtener_recurso(self, multimedia_id, incluir_metadata=False):
        """
        Obtiene un recurso multimedia por su ID.
        
        Args:
            multimedia_id (int): ID del recurso
            incluir_metadata (bool): Si incluir metadata completa
        
        Returns:
            tuple: (dict con recurso o error, c√≥digo HTTP)
        """
        multimedia = Multimedia.query.get(multimedia_id)
        
        if not multimedia:
            return {"error": "Recurso multimedia no encontrado"}, 404
        
        # Incrementar contador de uso
        multimedia.incrementar_uso()
        db.session.commit()
        
        return {
            "multimedia": multimedia.to_dict(incluir_metadata=incluir_metadata)
        }, 200
    
    def listar_recursos(self, filtros=None, pagina=1, por_pagina=20):
        """
        Lista recursos multimedia con filtros y paginaci√≥n.
        
        Args:
            filtros (dict): Filtros opcionales
                {
                    'tipo': str,
                    'categoria': str,
                    'estado': str,
                    'buscar': str,
                    'etiqueta': str
                }
            pagina (int): N√∫mero de p√°gina
            por_pagina (int): Recursos por p√°gina
        
        Returns:
            tuple: (dict con recursos paginados, c√≥digo HTTP)
        """
        try:
            query = Multimedia.query
            
            # Aplicar filtros
            if filtros:
                if filtros.get('tipo'):
                    try:
                        tipo = TipoMultimedia[filtros['tipo'].upper()]
                        query = query.filter_by(tipo=tipo)
                    except KeyError:
                        pass
                
                if filtros.get('categoria'):
                    query = query.filter_by(categoria=filtros['categoria'])
                
                if filtros.get('estado'):
                    try:
                        estado = EstadoMultimedia[filtros['estado'].upper()]
                        query = query.filter_by(estado=estado)
                    except KeyError:
                        pass
                
                if filtros.get('buscar'):
                    termino = f"%{filtros['buscar']}%"
                    query = query.filter(
                        or_(
                            Multimedia.nombre_archivo.ilike(termino),
                            Multimedia.descripcion.ilike(termino)
                        )
                    )
                
                if filtros.get('etiqueta'):
                    query = query.filter(
                        Multimedia.etiquetas.contains([filtros['etiqueta']])
                    )
            
            # Ordenar por fecha de creaci√≥n
            query = query.order_by(Multimedia.creado_en.desc())
            
            # Paginar
            paginacion = query.paginate(
                page=pagina,
                per_page=por_pagina,
                error_out=False
            )
            
            return {
                "recursos": [recurso.to_dict() for recurso in paginacion.items],
                "total": paginacion.total,
                "pagina": paginacion.page,
                "paginas_totales": paginacion.pages,
                "tiene_siguiente": paginacion.has_next,
                "tiene_anterior": paginacion.has_prev
            }, 200
            
        except Exception as e:
            return {"error": f"Error al listar recursos: {str(e)}"}, 500
    
    def actualizar_recurso(self, multimedia_id, datos_actualizados):
        """
        Actualiza informaci√≥n de un recurso multimedia.
        
        Args:
            multimedia_id (int): ID del recurso
            datos_actualizados (dict): Datos a actualizar
        
        Returns:
            tuple: (dict con recurso actualizado, c√≥digo HTTP)
        """
        try:
            multimedia = Multimedia.query.get(multimedia_id)
            
            if not multimedia:
                return {"error": "Recurso no encontrado"}, 404
            
            # Campos editables
            campos_editables = [
                'descripcion', 'alt_text', 'transcripcion',
                'etiquetas', 'categoria'
            ]
            
            for campo in campos_editables:
                if campo in datos_actualizados:
                    setattr(multimedia, campo, datos_actualizados[campo])
            
            multimedia.actualizado_en = datetime.utcnow()
            db.session.commit()
            
            return {
                "mensaje": "Recurso actualizado exitosamente",
                "multimedia": multimedia.to_dict()
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al actualizar recurso: {str(e)}"}, 500
    
    def eliminar_recurso(self, multimedia_id, eliminar_archivo=True):
        """
        Elimina un recurso multimedia.
        
        Args:
            multimedia_id (int): ID del recurso
            eliminar_archivo (bool): Si eliminar archivo f√≠sico
        
        Returns:
            tuple: (dict con resultado, c√≥digo HTTP)
        """
        try:
            multimedia = Multimedia.query.get(multimedia_id)
            
            if not multimedia:
                return {"error": "Recurso no encontrado"}, 404
            
            # Verificar si est√° en uso
            if multimedia.lecciones.count() > 0:
                return {
                    "error": "El recurso est√° siendo usado en lecciones y no puede eliminarse"
                }, 400
            
            # Eliminar archivo f√≠sico si existe
            if eliminar_archivo and multimedia.ruta_local:
                ruta = Path(multimedia.ruta_local)
                if ruta.exists():
                    ruta.unlink()
                
                # Eliminar thumbnail si existe
                if multimedia.url_thumbnail:
                    ruta_thumb = Path(multimedia.url_thumbnail.lstrip('/'))
                    if ruta_thumb.exists():
                        ruta_thumb.unlink()
            
            db.session.delete(multimedia)
            db.session.commit()
            
            return {
                "mensaje": "Recurso eliminado exitosamente",
                "multimedia_id": multimedia_id
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al eliminar recurso: {str(e)}"}, 500
    
    def asociar_con_leccion(self, multimedia_id, leccion_id, orden=0):
        """
        Asocia un recurso multimedia con una lecci√≥n.
        
        Args:
            multimedia_id (int): ID del recurso
            leccion_id (int): ID de la lecci√≥n
            orden (int): Orden del recurso en la lecci√≥n
        
        Returns:
            tuple: (dict con resultado, c√≥digo HTTP)
        """
        try:
            multimedia = Multimedia.query.get(multimedia_id)
            leccion = Leccion.query.get(leccion_id)
            
            if not multimedia:
                return {"error": "Recurso multimedia no encontrado"}, 404
            
            if not leccion:
                return {"error": "Lecci√≥n no encontrada"}, 404
            
            # Verificar si ya est√° asociado
            if multimedia in leccion.recursos_multimedia:
                return {
                    "mensaje": "El recurso ya est√° asociado con esta lecci√≥n"
                }, 200
            
            leccion.recursos_multimedia.append(multimedia)
            multimedia.incrementar_uso()
            db.session.commit()
            
            return {
                "mensaje": "Recurso asociado exitosamente con la lecci√≥n",
                "multimedia_id": multimedia_id,
                "leccion_id": leccion_id
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al asociar recurso: {str(e)}"}, 500
    
    def desasociar_de_leccion(self, multimedia_id, leccion_id):
        """
        Desasocia un recurso multimedia de una lecci√≥n.
        
        Args:
            multimedia_id (int): ID del recurso
            leccion_id (int): ID de la lecci√≥n
        
        Returns:
            tuple: (dict con resultado, c√≥digo HTTP)
        """
        try:
            multimedia = Multimedia.query.get(multimedia_id)
            leccion = Leccion.query.get(leccion_id)
            
            if not multimedia or not leccion:
                return {"error": "Recurso o lecci√≥n no encontrados"}, 404
            
            if multimedia in leccion.recursos_multimedia:
                leccion.recursos_multimedia.remove(multimedia)
                db.session.commit()
            
            return {
                "mensaje": "Recurso desasociado exitosamente",
                "multimedia_id": multimedia_id,
                "leccion_id": leccion_id
            }, 200
            
        except Exception as e:
            db.session.rollback()
            return {"error": f"Error al desasociar recurso: {str(e)}"}, 500
    
    # ========== M√âTODOS AUXILIARES ==========
    
    def _detectar_tipo_multimedia(self, mime_type):
        """
        Detecta el tipo de multimedia basado en MIME type.
        
        Args:
            mime_type (str): Tipo MIME
        
        Returns:
            TipoMultimedia o None
        """
        if mime_type.startswith('image/'):
            return TipoMultimedia.IMAGEN
        elif mime_type.startswith('audio/'):
            return TipoMultimedia.AUDIO
        elif mime_type.startswith('video/'):
            return TipoMultimedia.VIDEO
        elif mime_type in ['application/pdf', 'text/plain']:
            return TipoMultimedia.DOCUMENTO
        return None
    
    def _obtener_tamano_maximo(self, tipo):
        """
        Obtiene el tama√±o m√°ximo permitido para un tipo.
        
        Args:
            tipo (TipoMultimedia): Tipo de multimedia
        
        Returns:
            int: Tama√±o m√°ximo en bytes
        """
        claves = {
            TipoMultimedia.IMAGEN: 'max_tamano_imagen',
            TipoMultimedia.AUDIO: 'max_tamano_audio',
            TipoMultimedia.VIDEO: 'max_tamano_video',
            TipoMultimedia.DOCUMENTO: 'max_tamano_documento'
        }
        
        clave = claves.get(tipo, 'max_tamano_imagen')
        valor = ConfiguracionMultimedia.obtener_valor(clave, '5242880')
        
        return int(valor)
    
    def _obtener_dimensiones_imagen(self, ruta_archivo):
        """
        Obtiene dimensiones de una imagen.
        
        Args:
            ruta_archivo (Path): Ruta del archivo
        
        Returns:
            dict: {'ancho': int, 'alto': int} o None
        """
        try:
            try:
                from PIL import Image
            except ImportError:
                # PIL no est√° instalado, retornar None
                return None
            
            with Image.open(ruta_archivo) as img:
                return {
                    'ancho': img.width,
                    'alto': img.height
                }
        except Exception:
            return None
    
    def _obtener_dimensiones_video(self, ruta_archivo):
        """
        Obtiene dimensiones de un video.
        
        Args:
            ruta_archivo (Path): Ruta del archivo
        
        Returns:
            dict: {'ancho': int, 'alto': int} o None
        """
        # Requiere ffmpeg-python o similar
        # Implementaci√≥n simplificada
        return None
    
    def _obtener_duracion_media(self, ruta_archivo):
        """
        Obtiene duraci√≥n de audio/video.
        
        Args:
            ruta_archivo (Path): Ruta del archivo
        
        Returns:
            int: Duraci√≥n en segundos o None
        """
        # Requiere ffmpeg-python o similar
        # Implementaci√≥n simplificada
        return None
    
    def _generar_thumbnail(self, ruta_archivo, nombre_almacenado, tipo):
        """
        Genera thumbnail para imagen o video.
        
        Args:
            ruta_archivo (Path): Ruta del archivo original
            nombre_almacenado (str): Nombre del archivo
            tipo (TipoMultimedia): Tipo de multimedia
        
        Returns:
            str: URL del thumbnail o None
        """
        try:
            if tipo != TipoMultimedia.IMAGEN:
                return None
            
            from PIL import Image
            
            ancho = int(ConfiguracionMultimedia.obtener_valor('thumbnail_ancho', '300'))
            alto = int(ConfiguracionMultimedia.obtener_valor('thumbnail_alto', '300'))
            
            # Crear directorio de thumbnails
            ruta_base = ConfiguracionMultimedia.obtener_valor(
                'ruta_almacenamiento',
                'uploads/multimedia'
            )
            ruta_thumbs = Path(ruta_base) / 'thumbnails'
            ruta_thumbs.mkdir(parents=True, exist_ok=True)
            
            # Generar thumbnail
            nombre_thumb = f"thumb_{nombre_almacenado}"
            ruta_thumb = ruta_thumbs / nombre_thumb
            
            with Image.open(ruta_archivo) as img:
                img.thumbnail((ancho, alto), Image.Resampling.LANCZOS)
                img.save(ruta_thumb, quality=85)
            
            return f"/{ruta_base}/thumbnails/{nombre_thumb}"
            
        except Exception:
            return None
    
    # ========== ESTAD√çSTICAS ==========
    
    def obtener_estadisticas(self):
        """
        Obtiene estad√≠sticas generales de multimedia.
        
        Returns:
            tuple: (dict con estad√≠sticas, c√≥digo HTTP)
        """
        try:
            total = Multimedia.query.count()
            
            por_tipo = {}
            for tipo in TipoMultimedia:
                count = Multimedia.query.filter_by(tipo=tipo).count()
                por_tipo[tipo.value] = count
            
            por_estado = {}
            for estado in EstadoMultimedia:
                count = Multimedia.query.filter_by(estado=estado).count()
                por_estado[estado.value] = count
            
            # Tama√±o total
            tamano_total = db.session.query(
                db.func.sum(Multimedia.tamano)
            ).scalar() or 0
            
            # Recursos m√°s usados
            mas_usados = Multimedia.query.order_by(
                Multimedia.veces_usado.desc()
            ).limit(10).all()
            
            return {
                "total_recursos": total,
                "por_tipo": por_tipo,
                "por_estado": por_estado,
                "tamano_total_bytes": tamano_total,
                "tamano_total_mb": round(tamano_total / (1024 * 1024), 2),
                "mas_usados": [
                    {
                        "id": r.id,
                        "nombre": r.nombre_archivo,
                        "tipo": r.tipo.value,
                        "veces_usado": r.veces_usado
                    }
                    for r in mas_usados
                ]
            }, 200
            
        except Exception as e:
            return {"error": f"Error al obtener estad√≠sticas: {str(e)}"}, 500


# Instancia global del gestor (SIN inicializar configuraci√≥n hasta que se use)
gestor_multimedia = GestorMultimedia()


================================================================================
# ARCHIVO: back-end/services/gestor_usuarios.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_usuarios.py
================================================================================

from config.database import db
from models.usuario import Usuario, PerfilUsuario, PerfilEstudiante, PerfilProfesor, PerfilAdministrador
from services.correo_service import (
    enviar_codigo_verificacion,
    enviar_recuperacion_password
)
from sqlalchemy.exc import IntegrityError
from datetime import datetime, timedelta
import random
import secrets

class GestorUsuarios:
    # ========================================
    # REGISTRO Y VERIFICACI√ìN
    # ========================================
    def registrar_usuario(self, nombre, primer_apellido, segundo_apellido, correo, password, idioma, nivel_actual):
        """
        Registra un nuevo usuario ESTUDIANTE.
        Crea: Usuario (rol='alumno') + PerfilUsuario (base) + PerfilEstudiante (espec√≠fico)
        """
        # Evitar duplicados por correo
        if Usuario.query.filter_by(correo=correo).first():
            return {"error": "El correo electr√≥nico ya est√° registrado."}, 400

        try:
            # 1. Crear usuario principal
            nuevo_usuario = Usuario(
                nombre=nombre,
                primer_apellido=primer_apellido,
                segundo_apellido=segundo_apellido,
                correo=correo,
                rol='alumno'  # Siempre alumno en registro p√∫blico
            )
            nuevo_usuario.set_password(password)

            # Generar ID p√∫blico √∫nico
            nuevo_usuario.id_publico = self.generar_id_publico(
                nombre, primer_apellido, segundo_apellido, idioma, nivel_actual
            )

            # Crear c√≥digo de verificaci√≥n (v√°lido por 10 minutos)
            codigo = str(random.randint(100000, 999999))
            nuevo_usuario.codigo_verificacion = codigo
            nuevo_usuario.expira_verificacion = datetime.utcnow() + timedelta(minutes=10)

            db.session.add(nuevo_usuario)
            db.session.flush()  # Para obtener el ID del usuario

            # 2. Crear perfil base (com√∫n para todos los roles)
            nombre_completo = f"{nombre} {primer_apellido} {segundo_apellido or ''}".strip()
            nuevo_perfil_base = PerfilUsuario(
                usuario_id=nuevo_usuario.id,
                nombre_completo=nombre_completo,
                id_publico=nuevo_usuario.id_publico
            )
            db.session.add(nuevo_perfil_base)

            # 3. Crear perfil espec√≠fico de ESTUDIANTE
            nuevo_perfil_estudiante = PerfilEstudiante(
                usuario_id=nuevo_usuario.id,
                nivel_actual=nivel_actual,
                idioma_aprendizaje=idioma,
                total_xp=0,
                nivel_usuario=1,
                dias_racha=0,
                racha_maxima=0,
                lecciones_completadas=0,
                tiempo_estudio_total=0,
                meta_diaria=30,
                notificaciones_habilitadas=True
            )
            db.session.add(nuevo_perfil_estudiante)

            # Guardar todo en BD
            db.session.commit()

            # Enviar correo de verificaci√≥n
            try:
                enviar_codigo_verificacion(correo, codigo)
                print(f"‚úÖ Correo de verificaci√≥n enviado a {correo}")
            except Exception as e:
                print(f"‚ö†Ô∏è Error al enviar correo de verificaci√≥n a {correo}: {e}")
                # No fallar el registro si el correo no se env√≠a

            return {
                "mensaje": "Usuario registrado correctamente. C√≥digo de verificaci√≥n enviado.",
                "id_publico": nuevo_usuario.id_publico,
                "usuario_id": nuevo_usuario.id
            }, 201

        except IntegrityError as e:
            db.session.rollback()
            print(f"‚ùå Error de integridad al registrar {correo}: {e}")
            return {"error": "Error de integridad en la base de datos (posiblemente ID p√∫blico duplicado)."}, 500
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error interno al registrar usuario {correo}: {str(e)}")
            return {"error": "Error interno del servidor"}, 500

    def verificar_correo(self, correo, codigo):
        """Verifica el correo electr√≥nico con el c√≥digo de 6 d√≠gitos"""
        usuario = Usuario.query.filter_by(correo=correo).first()
        if not usuario:
            return {"error": "Usuario no encontrado"}, 404

        if usuario.correo_verificado:
            return {"mensaje": "El correo ya est√° verificado"}, 200

        # Verificar expiraci√≥n (10 minutos)
        if usuario.expira_verificacion:
            if datetime.utcnow() > usuario.expira_verificacion:
                return {"error": "C√≥digo expirado. Solicita uno nuevo."}, 400
        else:
            return {"error": "No se pudo verificar la expiraci√≥n del c√≥digo."}, 400

        # Verificar c√≥digo
        if usuario.codigo_verificacion == codigo:
            usuario.correo_verificado = True
            usuario.codigo_verificacion = None
            usuario.expira_verificacion = None
            try:
                db.session.commit()
                print(f"‚úÖ Correo verificado para {correo}")
                return {"mensaje": "Correo verificado correctamente"}, 200
            except Exception as e:
                db.session.rollback()
                print(f"‚ùå Error al guardar verificaci√≥n para {correo}: {str(e)}")
                return {"error": "Error al guardar la verificaci√≥n"}, 500
        else:
            return {"error": "C√≥digo incorrecto"}, 400

    def reenviar_codigo(self, correo):
        """Reenv√≠a el c√≥digo de verificaci√≥n"""
        usuario = Usuario.query.filter_by(correo=correo).first()
        if not usuario:
            return {"error": "Usuario no encontrado"}, 404

        if usuario.correo_verificado:
            return {"mensaje": "El correo ya fue verificado"}, 200

        # Generar nuevo c√≥digo y actualizar expiraci√≥n
        codigo = str(random.randint(100000, 999999))
        usuario.codigo_verificacion = codigo
        usuario.expira_verificacion = datetime.utcnow() + timedelta(minutes=10)
        
        try:
            db.session.commit()
            # Enviar correo (solo despu√©s de confirmar que se guard√≥ en BD)
            enviar_codigo_verificacion(correo, codigo)
            print(f"‚úÖ C√≥digo reenviado a {correo}")
            return {"mensaje": "C√≥digo reenviado exitosamente"}, 200
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error al reenviar c√≥digo para {correo}: {str(e)}")
            return {"error": "Error al procesar el reenv√≠o del c√≥digo"}, 500

    # ========================================
    # AUTENTICACI√ìN (ACTUALIZADO)
    # ========================================
    def autenticar_usuario(self, correo, password):
        """
        Autentica un usuario y retorna su informaci√≥n completa seg√∫n su rol.
        Funciona para: alumno, profesor, admin, mantenimiento.
        """
        usuario = Usuario.query.filter_by(correo=correo).first()
        
        # Verificar usuario y contrase√±a
        if not usuario or not usuario.check_password(password):
            return {"error": "Credenciales inv√°lidas"}, 401

        # Verificar estado de la cuenta
        if usuario.estado_cuenta == 'desactivado':
            dias_restantes = 0
            if usuario.fecha_desactivacion:
                if isinstance(usuario.fecha_desactivacion, datetime):
                    dias_transcurridos = (datetime.utcnow() - usuario.fecha_desactivacion).days
                    dias_restantes = max(0, 30 - dias_transcurridos)

            return {
                "error": "Tu cuenta ha sido desactivada",
                "codigo": "CUENTA_DESACTIVADA",
                "dias_restantes": dias_restantes,
                "usuario_id": usuario.id
            }, 403

        if usuario.estado_cuenta == 'eliminado':
            return {"error": "Esta cuenta ha sido eliminada permanentemente", "codigo": "CUENTA_ELIMINADA"}, 403

        # Verificar si el correo est√° verificado
        if not usuario.correo_verificado:
            return {"error": "Debes verificar tu correo electr√≥nico antes de iniciar sesi√≥n", "codigo": "EMAIL_NOT_VERIFIED"}, 403

        # Construir respuesta base
        perfil_base = usuario.perfil
        datos_usuario_respuesta = {
            "id": usuario.id,
            "id_publico": usuario.id_publico,
            "nombre": usuario.nombre,
            "primer_apellido": usuario.primer_apellido,
            "segundo_apellido": usuario.segundo_apellido,
            "correo": usuario.correo,
            "rol": usuario.rol,
            "correo_verificado": usuario.correo_verificado,
            "estado_cuenta": usuario.estado_cuenta,
            "perfil_base": None,
            "perfil_especifico": None
        }

        # Agregar perfil base si existe
        if perfil_base:
            datos_usuario_respuesta["perfil_base"] = {
                "nombre_completo": perfil_base.nombre_completo,
                "foto_perfil": perfil_base.foto_perfil,
                "biografia": perfil_base.biografia
            }

        # Agregar perfil espec√≠fico seg√∫n el rol
        if usuario.rol == 'alumno':
            perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario.id).first()
            if perfil_estudiante:
                datos_usuario_respuesta["perfil_especifico"] = {
                    "tipo": "estudiante",
                    "nivel_actual": perfil_estudiante.nivel_actual,
                    "idioma_aprendizaje": perfil_estudiante.idioma_aprendizaje,
                    "total_xp": perfil_estudiante.total_xp,
                    "nivel_usuario": perfil_estudiante.nivel_usuario,
                    "dias_racha": perfil_estudiante.dias_racha,
                    "racha_maxima": perfil_estudiante.racha_maxima,
                    "lecciones_completadas": perfil_estudiante.lecciones_completadas,
                    "tiempo_estudio_total": perfil_estudiante.tiempo_estudio_total,
                    "meta_diaria": perfil_estudiante.meta_diaria,
                    "ultima_actividad": perfil_estudiante.ultima_actividad.isoformat() if perfil_estudiante.ultima_actividad else None
                }
        
        elif usuario.rol == 'profesor':
            perfil_profesor = PerfilProfesor.query.filter_by(usuario_id=usuario.id).first()
            if perfil_profesor:
                datos_usuario_respuesta["perfil_especifico"] = {
                    "tipo": "profesor",
                    "especialidad": perfil_profesor.especialidad,
                    "a√±os_experiencia": perfil_profesor.a√±os_experiencia,
                    "estudiantes_totales": perfil_profesor.estudiantes_totales,
                    "cursos_creados": perfil_profesor.cursos_creados
                }
        
        elif usuario.rol in ('admin', 'mantenimiento'):
            perfil_admin = PerfilAdministrador.query.filter_by(usuario_id=usuario.id).first()
            if perfil_admin:
                datos_usuario_respuesta["perfil_especifico"] = {
                    "tipo": "administrador",
                    "nivel_acceso": perfil_admin.nivel_acceso,
                    "departamento": perfil_admin.departamento,
                    "permisos": perfil_admin.permisos
                }
            
        return {
            "mensaje": "Inicio de sesi√≥n exitoso",
            "usuario": datos_usuario_respuesta
        }, 200

    # ========================================
    # PERFIL DE USUARIO (ACTUALIZADO)
    # ========================================
    def obtener_perfil(self, id_usuario):
        """Obtiene el perfil completo de un usuario por su ID seg√∫n su rol"""
        try:
            usuario = Usuario.query.get(id_usuario)
            if not usuario:
                return {"error": "Usuario no encontrado"}, 404

            perfil_base = PerfilUsuario.query.filter_by(usuario_id=usuario.id).first()
            if not perfil_base:
                return {"error": "Perfil base no encontrado"}, 404

            # Construir respuesta base
            datos_respuesta = {
                "id": usuario.id,
                "id_publico": usuario.id_publico,
                "nombre": usuario.nombre,
                "primer_apellido": usuario.primer_apellido,
                "segundo_apellido": usuario.segundo_apellido,
                "correo": usuario.correo,
                "rol": usuario.rol,
                "correo_verificado": usuario.correo_verificado,
                "estado_cuenta": usuario.estado_cuenta,
                "creado_en": usuario.creado_en.isoformat() if usuario.creado_en else None,
                "actualizado_en": usuario.actualizado_en.isoformat() if usuario.actualizado_en else None,
                "perfil_base": {
                    "nombre_completo": perfil_base.nombre_completo,
                    "foto_perfil": perfil_base.foto_perfil,
                    "biografia": perfil_base.biografia
                }
            }

            # Agregar perfil espec√≠fico seg√∫n rol
            if usuario.rol == 'alumno':
                perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario.id).first()
                if perfil_estudiante:
                    datos_respuesta["perfil_estudiante"] = {
                        "nivel_actual": perfil_estudiante.nivel_actual,
                        "idioma_aprendizaje": perfil_estudiante.idioma_aprendizaje,
                        "total_xp": perfil_estudiante.total_xp,
                        "dias_racha": perfil_estudiante.dias_racha,
                        "ultima_actividad": perfil_estudiante.ultima_actividad.isoformat() if perfil_estudiante.ultima_actividad else None
                    }
            
            elif usuario.rol == 'profesor':
                perfil_profesor = PerfilProfesor.query.filter_by(usuario_id=usuario.id).first()
                if perfil_profesor:
                    datos_respuesta["perfil_profesor"] = {
                        "especialidad": perfil_profesor.especialidad,
                        "estudiantes_totales": perfil_profesor.estudiantes_totales
                    }
            
            elif usuario.rol in ('admin', 'mantenimiento'):
                perfil_admin = PerfilAdministrador.query.filter_by(usuario_id=usuario.id).first()
                if perfil_admin:
                    datos_respuesta["perfil_admin"] = {
                        "nivel_acceso": perfil_admin.nivel_acceso,
                        "departamento": perfil_admin.departamento
                    }

            return datos_respuesta, 200

        except Exception as e:
            print(f"‚ùå Error obteniendo perfil para ID {id_usuario}: {str(e)}")
            return {"error": "Error interno al obtener el perfil"}, 500

    # ========================================
    # CAMBIO DE CURSO/IDIOMA (SOLO ESTUDIANTES)
    # ========================================
    def cambiar_curso(self, usuario_id, nuevo_idioma, nuevo_nivel=None):
        """
        Cambia el idioma y/o nivel del ESTUDIANTE.
        Solo funciona para usuarios con rol 'alumno'.
        """
        try:
            usuario = Usuario.query.get(usuario_id)
            if not usuario:
                return {"error": "Usuario no encontrado"}, 404
            
            if usuario.rol != 'alumno':
                return {"error": "Solo los estudiantes pueden cambiar de curso"}, 403

            perfil_estudiante = PerfilEstudiante.query.filter_by(usuario_id=usuario_id).first()
            if not perfil_estudiante:
                return {"error": "Perfil de estudiante no encontrado"}, 404

            # Validar idiomas disponibles
            idiomas_disponibles = ["Ingl√©s", "Espa√±ol", "Franc√©s", "Alem√°n"]
            if nuevo_idioma not in idiomas_disponibles:
                return {"error": f"Idioma '{nuevo_idioma}' no disponible actualmente"}, 400

            idioma_anterior = perfil_estudiante.idioma_aprendizaje

            # Actualizar idioma
            perfil_estudiante.idioma_aprendizaje = nuevo_idioma
            
            # Actualizar nivel si se proporciona
            if nuevo_nivel:
                perfil_estudiante.nivel_actual = nuevo_nivel
            
            # Actualizar √∫ltima actividad
            perfil_estudiante.ultima_actividad = datetime.utcnow().date()
            
            db.session.commit()
            
            print(f"‚úÖ Curso cambiado para usuario {usuario_id}: {idioma_anterior} ‚Üí {nuevo_idioma}")
            
            return {
                "mensaje": f"Curso cambiado exitosamente a {nuevo_idioma}",
                "perfil": {
                    "idioma_aprendizaje": perfil_estudiante.idioma_aprendizaje,
                    "nivel_actual": perfil_estudiante.nivel_actual,
                    "total_xp": perfil_estudiante.total_xp,
                    "dias_racha": perfil_estudiante.dias_racha
                }
            }, 200
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error al cambiar curso para usuario {usuario_id}: {e}")
            return {"error": "Error interno al cambiar el curso"}, 500

    # ========================================
    # SOFT DELETE Y RECUPERACI√ìN DE CUENTA
    # ========================================
    def desactivar_cuenta(self, usuario_id, password):
        """Desactiva temporalmente la cuenta del usuario (soft delete)"""
        usuario = Usuario.query.get(usuario_id)
        if not usuario:
            return {"error": "Usuario no encontrado"}, 404

        if not usuario.check_password(password):
            return {"error": "Contrase√±a incorrecta"}, 401

        if usuario.estado_cuenta == 'desactivado':
            return {"mensaje": "La cuenta ya se encuentra desactivada"}, 200
        if usuario.estado_cuenta == 'eliminado':
            return {"error": "La cuenta ha sido eliminada permanentemente"}, 410

        usuario.estado_cuenta = 'desactivado'
        usuario.fecha_desactivacion = datetime.utcnow()
        try:
            db.session.commit()
            print(f"‚ö†Ô∏è Cuenta desactivada: usuario {usuario_id}")
            return {"mensaje": "Cuenta desactivada correctamente. Tienes 30 d√≠as para reactivarla."}, 200
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error al desactivar cuenta {usuario_id}: {e}")
            return {"error": "Error al guardar el estado de desactivaci√≥n"}, 500

    def reactivar_cuenta(self, usuario_id, password):
        """Reactiva una cuenta desactivada si est√° dentro del per√≠odo de 30 d√≠as"""
        usuario = Usuario.query.get(usuario_id)
        if not usuario:
            return {"error": "Usuario no encontrado"}, 404

        if usuario.estado_cuenta != 'desactivado':
            if usuario.estado_cuenta == 'activo':
                return {"mensaje": "La cuenta ya est√° activa"}, 200
            elif usuario.estado_cuenta == 'eliminado':
                return {"error": "Esta cuenta ha sido eliminada permanentemente"}, 410
            else:
                return {"error": f"Estado de cuenta desconocido: '{usuario.estado_cuenta}'"}, 400

        if not usuario.check_password(password):
            return {"error": "Contrase√±a incorrecta"}, 401

        # Verificar per√≠odo de 30 d√≠as
        if usuario.fecha_desactivacion:
            if isinstance(usuario.fecha_desactivacion, datetime):
                dias_transcurridos = (datetime.utcnow() - usuario.fecha_desactivacion).days
                if dias_transcurridos > 30:
                    return {"error": "El per√≠odo de 30 d√≠as para reactivar ha expirado"}, 410
            else:
                print(f"‚ö†Ô∏è Fecha de desactivaci√≥n inv√°lida para usuario {usuario_id}")
                return {"error": "No se pudo verificar el per√≠odo de reactivaci√≥n"}, 500
        else:
            print(f"‚ö†Ô∏è Intento de reactivar sin fecha de desactivaci√≥n: usuario {usuario_id}")
            return {"error": "Falta informaci√≥n para verificar el per√≠odo"}, 500

        usuario.estado_cuenta = 'activo'
        usuario.fecha_desactivacion = None
        try:
            db.session.commit()
            print(f"‚úÖ Cuenta reactivada: usuario {usuario_id}")
            return {"mensaje": "Cuenta reactivada correctamente"}, 200
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error al reactivar cuenta {usuario_id}: {e}")
            return {"error": "Error al guardar el estado de reactivaci√≥n"}, 500

    # ========================================
    # RECUPERACI√ìN DE CONTRASE√ëA
    # ========================================
    def solicitar_recuperacion_password(self, correo):
        """Genera un token seguro y env√≠a correo para restablecer contrase√±a"""
        usuario = Usuario.query.filter_by(correo=correo).first()
        if not usuario:
            print(f"‚ÑπÔ∏è Solicitud de recuperaci√≥n para correo no existente: {correo}")
            return {"mensaje": "Si tu correo est√° registrado, recibir√°s instrucciones."}, 200

        token = secrets.token_urlsafe(32)
        usuario.token_recuperacion = token
        usuario.expira_token_recuperacion = datetime.utcnow() + timedelta(hours=1)
        
        try:
            db.session.commit()
            enviar_recuperacion_password(correo, token)
            print(f"üîë Token de recuperaci√≥n generado para {correo}")
            return {"mensaje": "Si tu correo est√° registrado, recibir√°s instrucciones."}, 200
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error al solicitar recuperaci√≥n para {correo}: {str(e)}")
            return {"mensaje": "Ocurri√≥ un error. Intenta de nuevo m√°s tarde."}, 500

    def validar_token_recuperacion(self, token):
        """Valida si un token de recuperaci√≥n es v√°lido y no ha expirado"""
        usuario = Usuario.query.filter_by(token_recuperacion=token).first()
        
        if not usuario or not usuario.expira_token_recuperacion or \
           usuario.expira_token_recuperacion < datetime.utcnow():
            return {"error": "El enlace es inv√°lido o ha expirado. Solicita uno nuevo."}, 400
            
        return {"mensaje": "Token v√°lido"}, 200

    def restablecer_password(self, token, nueva_password):
        """Restablece la contrase√±a usando un token v√°lido"""
        usuario = Usuario.query.filter_by(token_recuperacion=token).first()
        
        if not usuario or not usuario.expira_token_recuperacion or \
           usuario.expira_token_recuperacion < datetime.utcnow():
            return {"error": "El enlace es inv√°lido o ha expirado."}, 400

        if len(nueva_password) < 8:
            return {"error": "La nueva contrase√±a debe tener al menos 8 caracteres"}, 400

        try:
            usuario.set_password(nueva_password)
            usuario.token_recuperacion = None
            usuario.expira_token_recuperacion = None
            db.session.commit()
            print(f"‚úÖ Contrase√±a restablecida para usuario {usuario.id}")
            return {"mensaje": "Tu contrase√±a ha sido restablecida. Ya puedes iniciar sesi√≥n."}, 200
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error al restablecer contrase√±a: {str(e)}")
            return {"error": "Error al guardar la nueva contrase√±a"}, 500

    # ========================================
    # UTILIDAD INTERNA
    # ========================================
    def generar_id_publico(self, nombre, primer_apellido, segundo_apellido, idioma, nivel):
        """
        Genera un ID p√∫blico √∫nico y legible.
        Formato: YY+IDIOMA(3)+INICIALES(3)+NIVEL(2)
        Ejemplo: 25INGPRAA1
        """
        a√±o = str(datetime.now().year)[-2:]
        idioma_codigo = idioma[:3].upper() if idioma else "XXX"
        
        i1 = primer_apellido[0].upper() if primer_apellido else ""
        i2 = segundo_apellido[0].upper() if segundo_apellido else ""
        i3 = nombre[0].upper() if nombre else ""
        iniciales = f"{i1}{i2}{i3}"[:3].ljust(3, 'X')

        nivel_codigo = nivel.upper() if nivel else "XX"

        base_id = f"{a√±o}{idioma_codigo}{iniciales}{nivel_codigo}"
        
        # Manejo de colisiones
        contador = 0
        id_publico_final = base_id
        while Usuario.query.filter_by(id_publico=id_publico_final).first() or \
              PerfilUsuario.query.filter_by(id_publico=id_publico_final).first():
            contador += 1
            id_publico_final = f"{base_id}{contador}"
            if contador > 99:
                print(f"‚ö†Ô∏è Problema generando ID √∫nico para base {base_id}")
                id_publico_final = f"{base_id}{secrets.token_hex(2).upper()}"
                break

        return id_publico_final


================================================================================
# ARCHIVO: back-end/test_password.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_password.py
================================================================================

# back-end/test_password.py
from app import create_app
from models.usuario import Usuario

def test_login(correo, password):
    app = create_app()
    
    with app.app_context():
        usuario = Usuario.query.filter_by(correo=correo).first()
        
        if not usuario:
            print(f"‚ùå Usuario con correo {correo} NO existe")
            return
        
        print(f"‚úÖ Usuario encontrado:")
        print(f"   - ID: {usuario.id}")
        print(f"   - Nombre: {usuario.nombre}")
        print(f"   - Correo: {usuario.correo}")
        print(f"   - Rol: {usuario.rol}")
        print(f"   - Verificado: {usuario.correo_verificado}")
        print(f"   - Hash almacenado: {usuario.contrasena_hash[:50]}...")
        
        print(f"\nüîê Probando contrase√±a...")
        if usuario.check_password(password):
            print("‚úÖ ¬°Contrase√±a CORRECTA!")
        else:
            print("‚ùå Contrase√±a INCORRECTA")
            print("\nIntenta registrarte de nuevo o usar recuperaci√≥n de contrase√±a")

if __name__ == "__main__":
    # Cambia estos valores por los tuyos
    correo = input("Correo: ")
    password = input("Contrase√±a: ")
    test_login(correo, password)


================================================================================
# ARCHIVO: back-end/test_routes.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_routes.py
================================================================================

# En la consola de Python o crear un archivo test_routes.py
from app import create_app

app = create_app()

with app.app_context():
    print("Rutas disponibles:")
    for rule in app.url_map.iter_rules():
        if '/api/usuario' in str(rule):
            print(f"  {rule.methods} {rule}")

# back-end/url/test_routes.py


================================================================================
# ARCHIVO: back-end/url/contenido/contenido_txt.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/contenido/contenido_txt.py
================================================================================

# download_project_content.py
import requests
import os
import argparse
import json
from datetime import datetime
from colorama import Fore, Style, init
import time
import re

init(autoreset=True)

def sanitize_filename(filename):
    """Limpia el nombre de archivo para que sea v√°lido en sistemas de archivos"""
    return re.sub(r'[<>:"/\\|?*]', '_', filename)

def download_file_content(url, max_retries=3):
    """Descarga el contenido de un archivo con reintentos"""
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=30)
            if response.status_code == 200:
                return response.text
            elif response.status_code == 404:
                return f"# ERROR: Archivo no encontrado (404)\n# URL: {url}"
            elif response.status_code == 403:
                time.sleep(2)  # Esperar por rate limiting
                continue
            else:
                return f"# ERROR: C√≥digo {response.status_code}\n# URL: {url}"
        except requests.exceptions.RequestException as e:
            if attempt < max_retries - 1:
                time.sleep(1)
                continue
            return f"# ERROR: {str(e)}\n# URL: {url}"
    
    return f"# ERROR: Fallo despu√©s de {max_retries} intentos\n# URL: {url}"

def get_project_structure(user, repo, branch="main"):
    """Obtiene la estructura del proyecto desde GitHub API"""
    url = f"https://api.github.com/repos/{user}/{repo}/git/trees/{branch}?recursive=1"
    
    token = os.getenv("GITHUB_TOKEN")
    headers = {"Authorization": f"token {token}"} if token else {}
    
    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        print(f"{Fore.RED}‚ùå Error {response.status_code} al acceder al repositorio.{Style.RESET_ALL}")
        return []
    
    return response.json().get('tree', [])

def download_project_content(user, repo, branch="main", output_dir="project_content"):
    """Descarga el contenido completo del proyecto"""
    
    # Crear directorio de salida
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Obtener estructura del proyecto
    tree = get_project_structure(user, repo, branch)
    if not tree:
        return
    
    # Patrones para ignorar
    ignore_patterns = [
        'node_modules/', '__pycache__/', '.next/', 'venv/', 'env/', '.git/',
        'dist/', 'build/', '.env', 'package-lock.json', 'yarn.lock',
        '.vercel/', 'out/', '.gitignore', '.DS_Store', 'thumbs.db',
        '*.pyc', '*.log', '*.tmp'
    ]
    
    # Extensiones de archivo a procesar
    text_extensions = {
        '.py', '.tsx', '.ts', '.jsx', '.js', '.css', '.md', '.txt', 
        '.json', '.yml', '.yaml', '.xml', '.html', '.htm', '.sql',
        '.sh', '.bat', '.ps1', '.config', '.toml', '.ini'
    }
    
    backend_files = []
    frontend_files = []
    docs_files = []
    other_files = []
    
    print(f"\nüîç Escaneando proyecto: {Fore.CYAN}{repo}{Style.RESET_ALL}")
    print(f"üìÅ Descargando contenido a: {output_dir}/\n")
    
    total_files = 0
    for item in tree:
        path = item['path']
        
        # Ignorar archivos no deseados
        if any(pattern in path for pattern in ignore_patterns):
            continue
        
        # Solo procesar archivos de texto
        file_ext = os.path.splitext(path)[1].lower()
        if file_ext not in text_extensions:
            continue
        
        total_files += 1
        raw_url = f"https://raw.githubusercontent.com/{user}/{repo}/{branch}/{path}"
        
        # Clasificar archivos
        if path.startswith('back-end/'):
            backend_files.append({'path': path, 'url': raw_url})
            print(f"{Fore.GREEN}üêç Backend:{Style.RESET_ALL} {path}")
        elif path.startswith('front-end/'):
            frontend_files.append({'path': path, 'url': raw_url})
            print(f"{Fore.MAGENTA}‚öõÔ∏è  Frontend:{Style.RESET_ALL} {path}")
        elif path.startswith('docs/'):
            docs_files.append({'path': path, 'url': raw_url})
            print(f"{Fore.CYAN}üìò Docs:{Style.RESET_ALL} {path}")
        else:
            other_files.append({'path': path, 'url': raw_url})
            print(f"{Fore.YELLOW}üìÑ Otros:{Style.RESET_ALL} {path}")
    
    print(f"\nüìä Total de archivos a descargar: {total_files}")
    
    # Descargar y guardar contenido
    download_and_save_files(backend_files, "backend", output_dir)
    download_and_save_files(frontend_files, "frontend", output_dir)
    download_and_save_files(docs_files, "docs", output_dir)
    download_and_save_files(other_files, "other", output_dir)
    
    # Crear archivos consolidados
    create_consolidated_files(backend_files, frontend_files, docs_files, other_files, output_dir)
    
    return {
        "backend": backend_files,
        "frontend": frontend_files,
        "docs": docs_files,
        "other": other_files
    }

def download_and_save_files(files, category, output_dir):
    """Descarga y guarda archivos de una categor√≠a espec√≠fica"""
    if not files:
        return
    
    category_dir = os.path.join(output_dir, category)
    if not os.path.exists(category_dir):
        os.makedirs(category_dir)
    
    print(f"\nüì• Descargando {len(files)} archivos de {category}...")
    
    for i, file_info in enumerate(files, 1):
        path = file_info['path']
        url = file_info['url']
        
        # Crear nombre de archivo seguro
        safe_filename = sanitize_filename(path.replace('/', '_')) + '.txt'
        file_path = os.path.join(category_dir, safe_filename)
        
        # Descargar contenido
        content = download_file_content(url)
        
        # Guardar con metadatos
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(f"# ARCHIVO: {path}\n")
            f.write(f"# URL: {url}\n")
            f.write(f"# FECHA DESCARGA: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("# " + "=" * 50 + "\n\n")
            f.write(content)
        
        print(f"  [{i}/{len(files)}] ‚úÖ {safe_filename}")
        
        # Peque√±a pausa para no saturar GitHub
        time.sleep(0.1)

def create_consolidated_files(backend, frontend, docs, other, output_dir):
    """Crea archivos consolidados por categor√≠a"""
    print(f"\nüì¶ Creando archivos consolidados...")
    
    # Backend consolidado
    if backend:
        with open(os.path.join(output_dir, 'BACKEND_COMPLETO.txt'), 'w', encoding='utf-8') as f:
            f.write("# BACKEND COMPLETO - SpeakLexi\n")
            f.write(f"# Total archivos: {len(backend)}\n")
            f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            for file_info in backend:
                f.write(f"\n{'='*80}\n")
                f.write(f"# ARCHIVO: {file_info['path']}\n")
                f.write(f"# URL: {file_info['url']}\n")
                f.write(f"{'='*80}\n\n")
                content = download_file_content(file_info['url'])
                f.write(content)
                f.write("\n\n")
        print("  ‚úÖ BACKEND_COMPLETO.txt")
    
    # Frontend consolidado
    if frontend:
        with open(os.path.join(output_dir, 'FRONTEND_COMPLETO.txt'), 'w', encoding='utf-8') as f:
            f.write("# FRONTEND COMPLETO - SpeakLexi\n")
            f.write(f"# Total archivos: {len(frontend)}\n")
            f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            for file_info in frontend:
                f.write(f"\n{'='*80}\n")
                f.write(f"# ARCHIVO: {file_info['path']}\n")
                f.write(f"# URL: {file_info['url']}\n")
                f.write(f"{'='*80}\n\n")
                content = download_file_content(file_info['url'])
                f.write(content)
                f.write("\n\n")
        print("  ‚úÖ FRONTEND_COMPLETO.txt")
    
    # Proyecto completo
    all_files = backend + frontend + docs + other
    if all_files:
        with open(os.path.join(output_dir, 'PROYECTO_COMPLETO.txt'), 'w', encoding='utf-8') as f:
            f.write("# PROYECTO COMPLETO - SpeakLexi\n")
            f.write(f"# Backend: {len(backend)} archivos\n")
            f.write(f"# Frontend: {len(frontend)} archivos\n")
            f.write(f"# Docs: {len(docs)} archivos\n")
            f.write(f"# Otros: {len(other)} archivos\n")
            f.write(f"# Total: {len(all_files)} archivos\n")
            f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            for category, files in [
                ("BACKEND", backend),
                ("FRONTEND", frontend),
                ("DOCUMENTACI√ìN", docs),
                ("OTROS", other)
            ]:
                if files:
                    f.write(f"\n{'#'*80}\n")
                    f.write(f"# {category}\n")
                    f.write(f"{'#'*80}\n\n")
                    
                    for file_info in files:
                        f.write(f"\n{'='*80}\n")
                        f.write(f"# ARCHIVO: {file_info['path']}\n")
                        f.write(f"# URL: {file_info['url']}\n")
                        f.write(f"{'='*80}\n\n")
                        content = download_file_content(file_info['url'])
                        f.write(content)
                        f.write("\n\n")
        print("  ‚úÖ PROYECTO_COMPLETO.txt")
    
    # Metadata JSON
    metadata = {
        "project": "SpeakLexi",
        "backend_files": len(backend),
        "frontend_files": len(frontend),
        "docs_files": len(docs),
        "other_files": len(other),
        "total_files": len(all_files),
        "generated": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        "files": {
            "backend": [f["path"] for f in backend],
            "frontend": [f["path"] for f in frontend],
            "docs": [f["path"] for f in docs],
            "other": [f["path"] for f in other]
        }
    }
    
    with open(os.path.join(output_dir, 'metadata.json'), 'w', encoding='utf-8') as f:
        json.dump(metadata, f, indent=2, ensure_ascii=False)
    print("  ‚úÖ metadata.json")

def main():
    parser = argparse.ArgumentParser(description="Descarga el contenido completo de un repositorio GitHub")
    parser.add_argument("user", help="Usuario o organizaci√≥n de GitHub")
    parser.add_argument("repo", help="Nombre del repositorio")
    parser.add_argument("--branch", default="main", help="Rama del repositorio")
    parser.add_argument("--output", default="project_content", help="Directorio de salida")
    
    args = parser.parse_args()
    
    start_time = time.time()
    
    try:
        result = download_project_content(
            args.user, 
            args.repo, 
            args.branch, 
            args.output
        )
        
        end_time = time.time()
        duration = end_time - start_time
        
        print(f"\n{'='*60}")
        print("üéâ DESCARGA COMPLETADA")
        print(f"{'='*60}")
        print(f"üìÅ Contenido guardado en: {args.output}/")
        print(f"‚è±Ô∏è  Tiempo total: {duration:.2f} segundos")
        print(f"üìä Archivos descargados:")
        print(f"   üêç Backend: {len(result['backend'])} archivos")
        print(f"   ‚öõÔ∏è  Frontend: {len(result['frontend'])} archivos")
        print(f"   üìò Docs: {len(result['docs'])} archivos")
        print(f"   üìÑ Otros: {len(result['other'])} archivos")
        print(f"   üì¶ Total: {sum(len(v) for v in result.values())} archivos")
        print(f"\nüìã Archivos generados:")
        print(f"   üìÑ PROYECTO_COMPLETO.txt - Todo el c√≥digo en un archivo")
        print(f"   üìÑ BACKEND_COMPLETO.txt  - Solo backend")
        print(f"   üìÑ FRONTEND_COMPLETO.txt - Solo frontend")
        print(f"   üìÅ {args.output}/backend/  - Archivos individuales backend")
        print(f"   üìÅ {args.output}/frontend/ - Archivos individuales frontend")
        print(f"   üìÅ {args.output}/docs/     - Archivos individuales docs")
        print(f"   üìÑ metadata.json - Metadatos del proyecto")
        print(f"\nüí° Ahora puedes compartir los .txt con cualquier IA")
        print(f"{'='*60}")
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error durante la descarga: {str(e)}{Style.RESET_ALL}")

if __name__ == "__main__":
    main()


================================================================================
# ARCHIVO: back-end/url/crear_perfiles.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/crear_perfiles.py
================================================================================

"""
Script para crear perfiles faltantes de usuarios insertados manualmente
Ejecutar: python crear_perfiles_faltantes.py
"""

from app import app
from config.database import db
from models.usuario import Usuario, PerfilUsuario
from datetime import datetime

def crear_perfiles_faltantes():
    """Crea PerfilUsuario para todos los usuarios que no lo tengan"""
    
    with app.app_context():
        # Buscar usuarios sin perfil
        usuarios_sin_perfil = Usuario.query.filter(
            ~Usuario.perfil.has()  # No tiene perfil asociado
        ).all()
        
        if not usuarios_sin_perfil:
            print("‚úÖ Todos los usuarios ya tienen perfil")
            return
        
        print(f"üìã Encontrados {len(usuarios_sin_perfil)} usuarios sin perfil")
        
        creados = 0
        errores = 0
        
        for usuario in usuarios_sin_perfil:
            try:
                # Construir nombre completo
                nombre_completo = f"{usuario.nombre} {usuario.primer_apellido}"
                if usuario.segundo_apellido:
                    nombre_completo += f" {usuario.segundo_apellido}"
                
                # Crear perfil con valores por defecto
                nuevo_perfil = PerfilUsuario(
                    usuario_id=usuario.id,
                    nombre_completo=nombre_completo.strip(),
                    id_publico=usuario.id_publico or f"USER_{usuario.id}",
                    idioma="Ingl√©s",  # Valor por defecto
                    nivel_actual="A1",  # Valor por defecto
                    curso_actual="Ingl√©s - A1",
                    total_xp=0,
                    dias_racha=0,
                    ultima_actividad=datetime.utcnow()
                )
                
                db.session.add(nuevo_perfil)
                creados += 1
                
                print(f"‚úÖ Perfil creado para: {usuario.correo} (ID: {usuario.id})")
                
            except Exception as e:
                errores += 1
                print(f"‚ùå Error con usuario {usuario.id} ({usuario.correo}): {e}")
                db.session.rollback()
        
        # Guardar cambios
        try:
            db.session.commit()
            print(f"\nüéâ Proceso completado:")
            print(f"   - Perfiles creados: {creados}")
            print(f"   - Errores: {errores}")
        except Exception as e:
            db.session.rollback()
            print(f"\n‚ùå Error al guardar cambios: {e}")

def verificar_perfiles():
    """Verifica el estado actual de usuarios y perfiles"""
    
    with app.app_context():
        total_usuarios = Usuario.query.count()
        total_perfiles = PerfilUsuario.query.count()
        usuarios_sin_perfil = Usuario.query.filter(~Usuario.perfil.has()).count()
        
        print("\nüìä Estado actual:")
        print(f"   - Total usuarios: {total_usuarios}")
        print(f"   - Total perfiles: {total_perfiles}")
        print(f"   - Usuarios sin perfil: {usuarios_sin_perfil}")
        
        if usuarios_sin_perfil > 0:
            print("\n‚ö†Ô∏è  Hay usuarios sin perfil que necesitan ser corregidos")
        else:
            print("\n‚úÖ Todos los usuarios tienen perfil")

if __name__ == "__main__":
    print("üîß CORRECCI√ìN DE PERFILES FALTANTES\n")
    
    # Verificar estado inicial
    verificar_perfiles()
    
    # Crear perfiles faltantes
    print("\n" + "="*50)
    crear_perfiles_faltantes()
    
    # Verificar estado final
    print("\n" + "="*50)
    verificar_perfiles()


================================================================================
# ARCHIVO: back-end/url/generar_hashes.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/generar_hashes.py
================================================================================

"""
Script para generar hashes de contrase√±a compatibles con Werkzeug/Flask
Ejecutar: python generate_hashes.py
"""

from werkzeug.security import generate_password_hash

# Contrase√±as de los usuarios demo
usuarios = {
    'estudiante@speaklexi.com': 'estudiante123',
    'profesor@speaklexi.com': 'profesor123',
    'admin@speaklexi.com': 'admin123',
    'mantenimiento@speaklexi.com': 'mantenimiento123'
}

print("=" * 70)
print("GENERANDO HASHES SCRYPT PARA USUARIOS DEMO")
print("=" * 70)
print()

for email, password in usuarios.items():
    hash_password = generate_password_hash(password, method='scrypt')
    print(f"-- {email}")
    print(f"-- Password: {password}")
    print(f"'{hash_password}',")
    print()

print("=" * 70)
print("SCRIPT SQL COMPLETO")
print("=" * 70)
print()

sql_template = """
DELETE FROM usuarios WHERE correo IN (
    'estudiante@speaklexi.com',
    'profesor@speaklexi.com', 
    'admin@speaklexi.com',
    'mantenimiento@speaklexi.com'
);

INSERT INTO usuarios (
    id_publico,
    nombre,
    primer_apellido,
    segundo_apellido,
    correo,
    contrasena_hash,
    rol,
    correo_verificado,
    estado_cuenta,
    creado_en,
    actualizado_en
) VALUES
"""

print(sql_template)

# Generar inserts
inserts = []
roles = [
    ('USR-001', 'Estudiante', 'Demo', 'estudiante@speaklexi.com', 'alumno'),
    ('USR-002', 'Profesor', 'Demo', 'profesor@speaklexi.com', 'profesor'),
    ('USR-003', 'Admin', 'Demo', 'admin@speaklexi.com', 'admin'),
    ('USR-004', 'Mantenimiento', 'Demo', 'mantenimiento@speaklexi.com', 'mantenimiento')
]

for id_pub, nombre, apellido, email, rol in roles:
    password = usuarios[email]
    hash_pass = generate_password_hash(password, method='scrypt')
    
    insert = f"""(
    '{id_pub}',
    '{nombre}',
    '{apellido}',
    '',
    '{email}',
    '{hash_pass}',
    '{rol}',
    TRUE,
    'activo',
    NOW(),
    NOW()
)"""
    inserts.append(insert)

print(",\n".join(inserts) + ";")
print()
print("-- ‚úÖ Hashes generados con scrypt (compatibles con Werkzeug)")


================================================================================
# ARCHIVO: back-end/url/get_all_urls.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls.py
================================================================================

# get_all_urls_fixed.py
import requests
from datetime import datetime

def get_tree(user, repo, branch="main"):
    url = f"https://api.github.com/repos/{user}/{repo}/git/trees/{branch}?recursive=1"
    response = requests.get(url)
    
    if response.status_code == 200:
        tree = response.json()
        
        backend_urls = []
        frontend_urls = []
        
        # Carpetas/archivos a IGNORAR
        ignore_patterns = [
            'node_modules/',
            '__pycache__/',
            '.next/',
            'venv/',
            'env/',
            '.git/',
            'dist/',
            'build/',
            '.env',
            'package-lock.json',
            'yarn.lock',
            '.vercel/',
            'out/'
        ]
        
        print("üîç Escaneando proyecto SpeakLexi...\n")
        
        for item in tree['tree']:
            path = item['path']
            
            # Ignorar patrones
            if any(pattern in path for pattern in ignore_patterns):
                continue
            
            raw_url = f"https://raw.githubusercontent.com/{user}/{repo}/{branch}/{path}"
            
            # Backend Python (back-end con gui√≥n)
            if path.startswith('back-end/') and path.endswith('.py'):
                print(f"üêç Backend: {path}")
                backend_urls.append({
                    'path': path,
                    'url': raw_url
                })
            
            # Frontend (front-end con gui√≥n)
            elif path.startswith('front-end/'):
                # Next.js/React/TypeScript files
                if any(path.endswith(ext) for ext in ['.tsx', '.ts', '.jsx', '.js', '.css']):
                    # Ignorar archivos de configuraci√≥n
                    if not any(config in path for config in ['next.config', 'postcss.config', 'tailwind.config']):
                        print(f"‚öõÔ∏è  Frontend: {path}")
                        frontend_urls.append({
                            'path': path,
                            'url': raw_url
                        })
        
        print("\n" + "="*60)
        print(f"‚úÖ Backend: {len(backend_urls)} archivos")
        print(f"‚úÖ Frontend: {len(frontend_urls)} archivos")
        print(f"‚úÖ Total: {len(backend_urls) + len(frontend_urls)} archivos")
        print("="*60)
        
        # Guardar Backend organizado
        if backend_urls:
            models = [u for u in backend_urls if '/models/' in u['path']]
            services = [u for u in backend_urls if '/services/' in u['path']]
            routes = [u for u in backend_urls if '/routes/' in u['path']]
            config = [u for u in backend_urls if '/config/' in u['path']]
            utils = [u for u in backend_urls if '/utils/' in u['path']]
            other = [u for u in backend_urls if not any(x in u['path'] for x in ['/models/', '/services/', '/routes/', '/config/', '/utils/'])]
            
            with open('urls_backend.txt', 'w', encoding='utf-8') as f:
                f.write(f"# BACKEND - SpeakLexi (Python/Flask)\n")
                f.write(f"# Total: {len(backend_urls)} archivos\n")
                f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                if config:
                    f.write(f"# ========== CONFIG ({len(config)}) ==========\n")
                    for item in config:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if models:
                    f.write(f"# ========== MODELS ({len(models)}) ==========\n")
                    for item in models:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if services:
                    f.write(f"# ========== SERVICES ({len(services)}) ==========\n")
                    for item in services:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if routes:
                    f.write(f"# ========== ROUTES ({len(routes)}) ==========\n")
                    for item in routes:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if utils:
                    f.write(f"# ========== UTILS ({len(utils)}) ==========\n")
                    for item in utils:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if other:
                    f.write(f"# ========== OTROS ({len(other)}) ==========\n")
                    for item in other:
                        f.write(item['url'] + '\n')
                    f.write('\n')
            
            print("\nüíæ Backend: urls_backend.txt")
        
        # Guardar Frontend organizado
        if frontend_urls:
            pages = [u for u in frontend_urls if '/app/' in u['path']]
            components = [u for u in frontend_urls if '/components/' in u['path']]
            lib = [u for u in frontend_urls if '/lib/' in u['path']]
            styles = [u for u in frontend_urls if '.css' in u['path'] or '/styles/' in u['path']]
            other = [u for u in frontend_urls if not any(x in u['path'] for x in ['/app/', '/components/', '/lib/', '.css', '/styles/'])]
            
            with open('urls_frontend.txt', 'w', encoding='utf-8') as f:
                f.write(f"# FRONTEND - SpeakLexi (Next.js 15/React 19/TypeScript)\n")
                f.write(f"# Total: {len(frontend_urls)} archivos\n")
                f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                if pages:
                    f.write(f"# ========== PAGES/APP ROUTER ({len(pages)}) ==========\n")
                    for item in pages:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if components:
                    f.write(f"# ========== COMPONENTS ({len(components)}) ==========\n")
                    for item in components:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if lib:
                    f.write(f"# ========== LIB/UTILS ({len(lib)}) ==========\n")
                    for item in lib:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if styles:
                    f.write(f"# ========== STYLES ({len(styles)}) ==========\n")
                    for item in styles:
                        f.write(item['url'] + '\n')
                    f.write('\n')
                
                if other:
                    f.write(f"# ========== OTROS ({len(other)}) ==========\n")
                    for item in other:
                        f.write(item['url'] + '\n')
                    f.write('\n')
            
            print("üíæ Frontend: urls_frontend.txt")
        
        # Archivo completo
        with open('urls_completo.txt', 'w', encoding='utf-8') as f:
            f.write(f"# PROYECTO COMPLETO - SpeakLexi\n")
            f.write(f"# Backend: {len(backend_urls)} archivos\n")
            f.write(f"# Frontend: {len(frontend_urls)} archivos\n")
            f.write(f"# Total: {len(backend_urls) + len(frontend_urls)} archivos\n")
            f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            f.write("# " + "="*58 + "\n")
            f.write("# BACKEND\n")
            f.write("# " + "="*58 + "\n\n")
            for item in backend_urls:
                f.write(item['url'] + '\n')
            
            f.write("\n# " + "="*58 + "\n")
            f.write("# FRONTEND\n")
            f.write("# " + "="*58 + "\n\n")
            for item in frontend_urls:
                f.write(item['url'] + '\n')
        
        print("üíæ Completo: urls_completo.txt")
        
        return backend_urls, frontend_urls
    else:
        print(f"‚ùå Error al acceder al repositorio: {response.status_code}")
        print("Verifica que el repositorio sea p√∫blico")
        return [], []

if __name__ == "__main__":
    backend, frontend = get_tree("sTr4yDev", "speakLexi", "main")
    
    print("\n" + "="*60)
    print("üéØ Archivos generados:")
    print("   üìÑ urls_backend.txt  - Solo backend organizado")
    print("   üìÑ urls_frontend.txt - Solo frontend organizado")
    print("   üìÑ urls_completo.txt - Todo junto")
    print("\nüí° Copia el contenido del archivo que quieras revisar")
    print("   y p√©galo aqu√≠ en el chat para an√°lisis completo üöÄ")
    print("="*60)


================================================================================
# ARCHIVO: back-end/url/get_all_urls_opt.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls_opt.py
================================================================================

# get_all_urls_optimized.py
import requests
import os
import argparse
import json
from datetime import datetime
from colorama import Fore, Style, init

init(autoreset=True)

def get_tree(user, repo, branch="main"):
    """Obtiene todos los archivos del repositorio (modo recursivo)"""
    url = f"https://api.github.com/repos/{user}/{repo}/git/trees/{branch}?recursive=1"

    # Token opcional (para evitar l√≠mites de API)
    token = os.getenv("GITHUB_TOKEN")
    headers = {"Authorization": f"token {token}"} if token else {}

    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        print(f"{Fore.RED}‚ùå Error {response.status_code} al acceder al repositorio.{Style.RESET_ALL}")
        if response.status_code == 403:
            print("‚ö†Ô∏è L√≠mite de solicitudes alcanzado o repositorio privado.")
        print("Verifica que el repositorio sea p√∫blico o usa un token con GITHUB_TOKEN.\n")
        return [], [], []

    tree = response.json()
    backend_urls, frontend_urls, docs_urls = [], [], []

    # Carpetas/archivos a IGNORAR
    ignore_patterns = [
        'node_modules/', '__pycache__/', '.next/', 'venv/', 'env/', '.git/',
        'dist/', 'build/', '.env', 'package-lock.json', 'yarn.lock',
        '.vercel/', 'out/'
    ]

    print(f"\nüîç Escaneando proyecto: {Fore.CYAN}{repo}{Style.RESET_ALL}\n")

    for item in tree.get('tree', []):
        path = item['path']
        if any(pattern in path for pattern in ignore_patterns):
            continue

        raw_url = f"https://raw.githubusercontent.com/{user}/{repo}/{branch}/{path}"

        # Backend
        if path.startswith('back-end/') and path.endswith('.py'):
            print(f"{Fore.GREEN}üêç Backend:{Style.RESET_ALL} {path}")
            backend_urls.append({'path': path, 'url': raw_url})

        # Frontend
        elif path.startswith('front-end/'):
            if any(path.endswith(ext) for ext in ['.tsx', '.ts', '.jsx', '.js', '.css']):
                if not any(cfg in path for cfg in ['next.config', 'postcss.config', 'tailwind.config']):
                    print(f"{Fore.MAGENTA}‚öõÔ∏è  Frontend:{Style.RESET_ALL} {path}")
                    frontend_urls.append({'path': path, 'url': raw_url})

        # Docs
        elif path.startswith('docs/'):
            if any(path.endswith(ext) for ext in ['.md', '.txt', '.pdf']):
                print(f"{Fore.CYAN}üìò Docs:{Style.RESET_ALL} {path}")
                docs_urls.append({'path': path, 'url': raw_url})

    # ==== Resumen ====
    print("\n" + "="*60)
    print(f"‚úÖ Backend:  {len(backend_urls)} archivos")
    print(f"‚úÖ Frontend: {len(frontend_urls)} archivos")
    print(f"‚úÖ Docs:     {len(docs_urls)} archivos")
    print(f"‚úÖ Total:    {len(backend_urls) + len(frontend_urls) + len(docs_urls)} archivos")
    print("="*60)

    # ==== Guardado de archivos ====
    save_urls("urls_backend.txt", backend_urls, "BACKEND - SpeakLexi (Python/Flask)")
    save_urls("urls_frontend.txt", frontend_urls, "FRONTEND - SpeakLexi (Next.js/React/TypeScript)")
    save_urls("urls_docs.txt", docs_urls, "DOCUMENTACI√ìN - SpeakLexi")

    # ==== Archivo completo ====
    save_combined(backend_urls, frontend_urls, docs_urls)

    # ==== JSON Export ====
    with open('urls_all.json', 'w', encoding='utf-8') as jf:
        json.dump({
            "backend": backend_urls,
            "frontend": frontend_urls,
            "docs": docs_urls,
            "generated": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }, jf, indent=2, ensure_ascii=False)
    print("üíæ JSON: urls_all.json")

    return backend_urls, frontend_urls, docs_urls


def save_urls(filename, urls, title):
    if not urls:
        return
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"# {title}\n")
        f.write(f"# Total: {len(urls)} archivos\n")
        f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        for item in urls:
            f.write(item['url'] + '\n')
    print(f"üíæ {filename}")


def save_combined(backend, frontend, docs):
    total = len(backend) + len(frontend) + len(docs)
    with open('urls_completo.txt', 'w', encoding='utf-8') as f:
        f.write(f"# PROYECTO COMPLETO - SpeakLexi\n")
        f.write(f"# Backend: {len(backend)} archivos\n")
        f.write(f"# Frontend: {len(frontend)} archivos\n")
        f.write(f"# Docs: {len(docs)} archivos\n")
        f.write(f"# Total: {total} archivos\n")
        f.write(f"# Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

        for section, data in [
            ("BACKEND", backend),
            ("FRONTEND", frontend),
            ("DOCS", docs)
        ]:
            f.write("# " + "="*58 + "\n")
            f.write(f"# {section}\n")
            f.write("# " + "="*58 + "\n\n")
            for item in data:
                f.write(item['url'] + '\n')
            f.write("\n")

    print("üíæ Completo: urls_completo.txt")


# ==== MAIN ====
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Genera URLs RAW de un repositorio de GitHub (organizadas por √°rea).")
    parser.add_argument("user", help="Usuario o organizaci√≥n de GitHub")
    parser.add_argument("repo", help="Nombre del repositorio")
    parser.add_argument("--branch", default="main", help="Rama del repositorio (por defecto: main)")
    args = parser.parse_args()

    backend, frontend, docs = get_tree(args.user, args.repo, args.branch)

    print("\n" + "="*60)
    print("üéØ Archivos generados:")
    print("   üìÑ urls_backend.txt  - Solo backend organizado")
    print("   üìÑ urls_frontend.txt - Solo frontend organizado")
    print("   üìÑ urls_docs.txt     - Solo documentaci√≥n")
    print("   üìÑ urls_completo.txt - Todo junto")
    print("   üìÑ urls_all.json     - Exportaci√≥n en JSON")
    print("\nüí° Usa un token de GitHub (export GITHUB_TOKEN=tu_token) si el repo es grande o privado üöÄ")
    print("="*60)



================================================================================
# ARCHIVO: back-end/url/get_front_end.py
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_front_end.py
================================================================================




================================================================================
# ARCHIVO: back-end/url/urls_all.json
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/urls_all.json
================================================================================

{
  "backend": [
    {
      "path": "back-end/app.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/app.py"
    },
    {
      "path": "back-end/config/__init__.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/__init__.py"
    },
    {
      "path": "back-end/config/database.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/database.py"
    },
    {
      "path": "back-end/config/settings.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/settings.py"
    },
    {
      "path": "back-end/extensions.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/extensions.py"
    },
    {
      "path": "back-end/models/cursos.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/cursos.py"
    },
    {
      "path": "back-end/models/leccion.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/leccion.py"
    },
    {
      "path": "back-end/models/multimedia.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/multimedia.py"
    },
    {
      "path": "back-end/models/usuario.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/usuario.py"
    },
    {
      "path": "back-end/routes/__init__.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/__init__.py"
    },
    {
      "path": "back-end/routes/actividades_routes.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/actividades_routes.py"
    },
    {
      "path": "back-end/routes/auth.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/auth.py"
    },
    {
      "path": "back-end/routes/curso_routes.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/curso_routes.py"
    },
    {
      "path": "back-end/routes/leccion_routes.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/leccion_routes.py"
    },
    {
      "path": "back-end/routes/multimedia_routes.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/multimedia_routes.py"
    },
    {
      "path": "back-end/routes/usuario_routes.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/usuario_routes.py"
    },
    {
      "path": "back-end/services/correo_service.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/correo_service.py"
    },
    {
      "path": "back-end/services/gestor_cursos.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_cursos.py"
    },
    {
      "path": "back-end/services/gestor_lecciones.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_lecciones.py"
    },
    {
      "path": "back-end/services/gestor_multimedia.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_multimedia.py"
    },
    {
      "path": "back-end/services/gestor_usuarios.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_usuarios.py"
    },
    {
      "path": "back-end/test_password.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_password.py"
    },
    {
      "path": "back-end/test_routes.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_routes.py"
    },
    {
      "path": "back-end/url/crear_perfiles.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/crear_perfiles.py"
    },
    {
      "path": "back-end/url/generar_hashes.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/generar_hashes.py"
    },
    {
      "path": "back-end/url/get_all_urls.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls.py"
    },
    {
      "path": "back-end/url/get_all_urls_opt.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls_opt.py"
    },
    {
      "path": "back-end/url/get_front_end.py",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_front_end.py"
    }
  ],
  "frontend": [
    {
      "path": "front-end/app/admin/dashboard/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/dashboard/page.tsx"
    },
    {
      "path": "front-end/app/admin/lecciones/[id]/editar/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/[id]/editar/page.tsx"
    },
    {
      "path": "front-end/app/admin/lecciones/crear/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/crear/page.tsx"
    },
    {
      "path": "front-end/app/admin/lecciones/loading.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/loading.tsx"
    },
    {
      "path": "front-end/app/admin/lecciones/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/page.tsx"
    },
    {
      "path": "front-end/app/admin/usuarios/[id]/editar/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/[id]/editar/page.tsx"
    },
    {
      "path": "front-end/app/admin/usuarios/loading.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/loading.tsx"
    },
    {
      "path": "front-end/app/admin/usuarios/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/page.tsx"
    },
    {
      "path": "front-end/app/asignar-nivel/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/asignar-nivel/page.tsx"
    },
    {
      "path": "front-end/app/cambiar-curso/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/cambiar-curso/page.tsx"
    },
    {
      "path": "front-end/app/clasificacion/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/clasificacion/page.tsx"
    },
    {
      "path": "front-end/app/correo-enviado/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/correo-enviado/page.tsx"
    },
    {
      "path": "front-end/app/cuenta-desactivada/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/cuenta-desactivada/page.tsx"
    },
    {
      "path": "front-end/app/dashboard/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/dashboard/page.tsx"
    },
    {
      "path": "front-end/app/eliminar-cuenta/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/eliminar-cuenta/page.tsx"
    },
    {
      "path": "front-end/app/globals.css",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/globals.css"
    },
    {
      "path": "front-end/app/layout.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/layout.tsx"
    },
    {
      "path": "front-end/app/lecciones/[id]/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/lecciones/[id]/page.tsx"
    },
    {
      "path": "front-end/app/lecciones/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/lecciones/page.tsx"
    },
    {
      "path": "front-end/app/login/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/login/page.tsx"
    },
    {
      "path": "front-end/app/logros/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/logros/page.tsx"
    },
    {
      "path": "front-end/app/mantenimiento/dashboard/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/dashboard/page.tsx"
    },
    {
      "path": "front-end/app/mantenimiento/reportes/[id]/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/[id]/page.tsx"
    },
    {
      "path": "front-end/app/mantenimiento/reportes/loading.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/loading.tsx"
    },
    {
      "path": "front-end/app/mantenimiento/reportes/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/page.tsx"
    },
    {
      "path": "front-end/app/mantenimiento/tareas/nueva/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/tareas/nueva/page.tsx"
    },
    {
      "path": "front-end/app/mantenimiento/tareas/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/tareas/page.tsx"
    },
    {
      "path": "front-end/app/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/page.tsx"
    },
    {
      "path": "front-end/app/perfil/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/perfil/page.tsx"
    },
    {
      "path": "front-end/app/profesor/dashboard/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/dashboard/page.tsx"
    },
    {
      "path": "front-end/app/profesor/estadisticas/[id]/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/[id]/page.tsx"
    },
    {
      "path": "front-end/app/profesor/estadisticas/loading.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/loading.tsx"
    },
    {
      "path": "front-end/app/profesor/estadisticas/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/page.tsx"
    },
    {
      "path": "front-end/app/profesor/planificacion/nuevo/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/planificacion/nuevo/page.tsx"
    },
    {
      "path": "front-end/app/profesor/planificacion/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/planificacion/page.tsx"
    },
    {
      "path": "front-end/app/profesor/retroalimentacion/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/retroalimentacion/page.tsx"
    },
    {
      "path": "front-end/app/progreso/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/progreso/page.tsx"
    },
    {
      "path": "front-end/app/recuperar-contrasena/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/recuperar-contrasena/page.tsx"
    },
    {
      "path": "front-end/app/registro/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/registro/page.tsx"
    },
    {
      "path": "front-end/app/restablecer-contrasena/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/restablecer-contrasena/page.tsx"
    },
    {
      "path": "front-end/app/restablecer-contrasena/reset-password-content.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/restablecer-contrasena/reset-password-content.tsx"
    },
    {
      "path": "front-end/app/verificar-email/page.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/verificar-email/page.tsx"
    },
    {
      "path": "front-end/components/admin/admin-stats.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/admin-stats.tsx"
    },
    {
      "path": "front-end/components/admin/create-lesson-form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/create-lesson-form.tsx"
    },
    {
      "path": "front-end/components/admin/media-library-preview.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/media-library-preview.tsx"
    },
    {
      "path": "front-end/components/admin/quick-admin-actions.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/quick-admin-actions.tsx"
    },
    {
      "path": "front-end/components/admin/recent-lessons.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/recent-lessons.tsx"
    },
    {
      "path": "front-end/components/auth/level-assignment-flow.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/level-assignment-flow.tsx"
    },
    {
      "path": "front-end/components/auth/login-form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/login-form.tsx"
    },
    {
      "path": "front-end/components/auth/recover-password-form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/recover-password-form.tsx"
    },
    {
      "path": "front-end/components/auth/register-form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/register-form.tsx"
    },
    {
      "path": "front-end/components/auth/verify-email-form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/verify-email-form.tsx"
    },
    {
      "path": "front-end/components/dashboard/dashboard-header.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/dashboard-header.tsx"
    },
    {
      "path": "front-end/components/dashboard/progress-overview.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/progress-overview.tsx"
    },
    {
      "path": "front-end/components/dashboard/quick-actions.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/quick-actions.tsx"
    },
    {
      "path": "front-end/components/dashboard/recent-lessons.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/recent-lessons.tsx"
    },
    {
      "path": "front-end/components/dashboard/streak-card.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/streak-card.tsx"
    },
    {
      "path": "front-end/components/gamification/achievements-list.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/achievements-list.tsx"
    },
    {
      "path": "front-end/components/gamification/leaderboard-filters.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/leaderboard-filters.tsx"
    },
    {
      "path": "front-end/components/gamification/leaderboard-table.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/leaderboard-table.tsx"
    },
    {
      "path": "front-end/components/gamification/level-progress.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/level-progress.tsx"
    },
    {
      "path": "front-end/components/gamification/rewards-inventory.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/rewards-inventory.tsx"
    },
    {
      "path": "front-end/components/gamification/user-rank-card.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/user-rank-card.tsx"
    },
    {
      "path": "front-end/components/lessons/abandon-lesson-modal.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/abandon-lesson-modal.tsx"
    },
    {
      "path": "front-end/components/lessons/activities/fill-blank-activity.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/fill-blank-activity.tsx"
    },
    {
      "path": "front-end/components/lessons/activities/listen-repeat-activity.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/listen-repeat-activity.tsx"
    },
    {
      "path": "front-end/components/lessons/activities/matching-activity.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/matching-activity.tsx"
    },
    {
      "path": "front-end/components/lessons/activities/multiple-choice-activity.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/multiple-choice-activity.tsx"
    },
    {
      "path": "front-end/components/lessons/activities/translation-activity.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/translation-activity.tsx"
    },
    {
      "path": "front-end/components/lessons/activities/true-false-activity.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/true-false-activity.tsx"
    },
    {
      "path": "front-end/components/lessons/activities/word-order-activity.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/word-order-activity.tsx"
    },
    {
      "path": "front-end/components/lessons/completion-modal.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/completion-modal.tsx"
    },
    {
      "path": "front-end/components/lessons/lesson-filters.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-filters.tsx"
    },
    {
      "path": "front-end/components/lessons/lesson-list.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-list.tsx"
    },
    {
      "path": "front-end/components/lessons/lesson-viewer.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-viewer.tsx"
    },
    {
      "path": "front-end/components/maintenance/create-task-form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/maintenance/create-task-form.tsx"
    },
    {
      "path": "front-end/components/profile/profile-settings.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/profile/profile-settings.tsx"
    },
    {
      "path": "front-end/components/teacher/create-planning-form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/create-planning-form.tsx"
    },
    {
      "path": "front-end/components/teacher/quick-teacher-actions.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/quick-teacher-actions.tsx"
    },
    {
      "path": "front-end/components/teacher/recent-feedback.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/recent-feedback.tsx"
    },
    {
      "path": "front-end/components/teacher/response-modal.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/response-modal.tsx"
    },
    {
      "path": "front-end/components/teacher/student-performance.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/student-performance.tsx"
    },
    {
      "path": "front-end/components/teacher/teacher-stats.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/teacher-stats.tsx"
    },
    {
      "path": "front-end/components/theme-provider.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/theme-provider.tsx"
    },
    {
      "path": "front-end/components/ui/accordion.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/accordion.tsx"
    },
    {
      "path": "front-end/components/ui/alert-dialog.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/alert-dialog.tsx"
    },
    {
      "path": "front-end/components/ui/alert.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/alert.tsx"
    },
    {
      "path": "front-end/components/ui/aspect-ratio.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/aspect-ratio.tsx"
    },
    {
      "path": "front-end/components/ui/avatar.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/avatar.tsx"
    },
    {
      "path": "front-end/components/ui/badge.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/badge.tsx"
    },
    {
      "path": "front-end/components/ui/breadcrumb.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/breadcrumb.tsx"
    },
    {
      "path": "front-end/components/ui/button-group.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/button-group.tsx"
    },
    {
      "path": "front-end/components/ui/button.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/button.tsx"
    },
    {
      "path": "front-end/components/ui/calendar.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/calendar.tsx"
    },
    {
      "path": "front-end/components/ui/card.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/card.tsx"
    },
    {
      "path": "front-end/components/ui/carousel.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/carousel.tsx"
    },
    {
      "path": "front-end/components/ui/chart.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/chart.tsx"
    },
    {
      "path": "front-end/components/ui/checkbox.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/checkbox.tsx"
    },
    {
      "path": "front-end/components/ui/collapsible.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/collapsible.tsx"
    },
    {
      "path": "front-end/components/ui/command.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/command.tsx"
    },
    {
      "path": "front-end/components/ui/context-menu.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/context-menu.tsx"
    },
    {
      "path": "front-end/components/ui/dialog.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/dialog.tsx"
    },
    {
      "path": "front-end/components/ui/drawer.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/drawer.tsx"
    },
    {
      "path": "front-end/components/ui/dropdown-menu.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/dropdown-menu.tsx"
    },
    {
      "path": "front-end/components/ui/empty.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/empty.tsx"
    },
    {
      "path": "front-end/components/ui/field.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/field.tsx"
    },
    {
      "path": "front-end/components/ui/form.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/form.tsx"
    },
    {
      "path": "front-end/components/ui/hover-card.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/hover-card.tsx"
    },
    {
      "path": "front-end/components/ui/input-group.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input-group.tsx"
    },
    {
      "path": "front-end/components/ui/input-otp.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input-otp.tsx"
    },
    {
      "path": "front-end/components/ui/input.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input.tsx"
    },
    {
      "path": "front-end/components/ui/item.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/item.tsx"
    },
    {
      "path": "front-end/components/ui/kbd.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/kbd.tsx"
    },
    {
      "path": "front-end/components/ui/label.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/label.tsx"
    },
    {
      "path": "front-end/components/ui/menubar.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/menubar.tsx"
    },
    {
      "path": "front-end/components/ui/navigation-menu.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/navigation-menu.tsx"
    },
    {
      "path": "front-end/components/ui/pagination.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/pagination.tsx"
    },
    {
      "path": "front-end/components/ui/popover.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/popover.tsx"
    },
    {
      "path": "front-end/components/ui/progress.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/progress.tsx"
    },
    {
      "path": "front-end/components/ui/radio-group.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/radio-group.tsx"
    },
    {
      "path": "front-end/components/ui/resizable.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/resizable.tsx"
    },
    {
      "path": "front-end/components/ui/scroll-area.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/scroll-area.tsx"
    },
    {
      "path": "front-end/components/ui/select.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/select.tsx"
    },
    {
      "path": "front-end/components/ui/separator.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/separator.tsx"
    },
    {
      "path": "front-end/components/ui/sheet.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sheet.tsx"
    },
    {
      "path": "front-end/components/ui/sidebar.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sidebar.tsx"
    },
    {
      "path": "front-end/components/ui/skeleton.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/skeleton.tsx"
    },
    {
      "path": "front-end/components/ui/slider.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/slider.tsx"
    },
    {
      "path": "front-end/components/ui/sonner.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sonner.tsx"
    },
    {
      "path": "front-end/components/ui/spinner.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/spinner.tsx"
    },
    {
      "path": "front-end/components/ui/switch.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/switch.tsx"
    },
    {
      "path": "front-end/components/ui/table.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/table.tsx"
    },
    {
      "path": "front-end/components/ui/tabs.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/tabs.tsx"
    },
    {
      "path": "front-end/components/ui/textarea.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/textarea.tsx"
    },
    {
      "path": "front-end/components/ui/toast.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toast.tsx"
    },
    {
      "path": "front-end/components/ui/toaster.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toaster.tsx"
    },
    {
      "path": "front-end/components/ui/toggle-group.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toggle-group.tsx"
    },
    {
      "path": "front-end/components/ui/toggle.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toggle.tsx"
    },
    {
      "path": "front-end/components/ui/tooltip.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/tooltip.tsx"
    },
    {
      "path": "front-end/components/ui/use-mobile.tsx",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/use-mobile.tsx"
    },
    {
      "path": "front-end/components/ui/use-toast.ts",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/use-toast.ts"
    },
    {
      "path": "front-end/hooks/use-mobile.ts",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-mobile.ts"
    },
    {
      "path": "front-end/hooks/use-toast.ts",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-toast.ts"
    },
    {
      "path": "front-end/hooks/use-user-data.ts",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-user-data.ts"
    },
    {
      "path": "front-end/middleware.ts",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/middleware.ts"
    },
    {
      "path": "front-end/next-env.d.ts",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/next-env.d.ts"
    },
    {
      "path": "front-end/styles/globals.css",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/styles/globals.css"
    }
  ],
  "docs": [
    {
      "path": "docs/README.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/README.md"
    },
    {
      "path": "docs/architecture.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/architecture.md"
    },
    {
      "path": "docs/database.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/database.md"
    },
    {
      "path": "docs/errores/bitacoras/ERRORES - 27 OCT 25.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/errores/bitacoras/ERRORES - 27 OCT 25.md"
    },
    {
      "path": "docs/guidelines/best-practices.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/best-practices.md"
    },
    {
      "path": "docs/guidelines/naming-conventions.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/naming-conventions.md"
    },
    {
      "path": "docs/guidelines/requisitos-funcionales.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/requisitos-funcionales.md"
    },
    {
      "path": "docs/workflows/lession-creation.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/workflows/lession-creation.md"
    },
    {
      "path": "docs/workflows/user-registration.md",
      "url": "https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/workflows/user-registration.md"
    }
  ],
  "generated": "2025-10-28 20:45:16"
}


================================================================================
# ARCHIVO: back-end/url/urls_backend.txt
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/urls_backend.txt
================================================================================

# BACKEND - SpeakLexi (Python/Flask)
# Total: 28 archivos
# Generado: 2025-10-28 20:45:16

https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/app.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/__init__.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/database.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/settings.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/extensions.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/cursos.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/leccion.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/multimedia.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/usuario.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/__init__.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/actividades_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/auth.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/curso_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/leccion_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/multimedia_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/usuario_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/correo_service.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_cursos.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_lecciones.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_multimedia.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_usuarios.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_password.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/crear_perfiles.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/generar_hashes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls_opt.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_front_end.py



================================================================================
# ARCHIVO: back-end/url/urls_backend_organizado.txt
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/urls_backend_organizado.txt
================================================================================

# Backend - SpeakLexi
# Total: 11 archivos

# ===== CONFIG (3) =====
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/__init__.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/database.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/settings.py

# ===== MODELS (1) =====
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/usuario.py

# ===== SERVICES (2) =====
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/correo_service.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_usuarios.py

# ===== ROUTES (3) =====
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/__init__.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/auth.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/usuario_routes.py




================================================================================
# ARCHIVO: back-end/url/urls_completo.txt
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/urls_completo.txt
================================================================================

# PROYECTO COMPLETO - SpeakLexi
# Backend: 28 archivos
# Frontend: 147 archivos
# Docs: 9 archivos
# Total: 184 archivos
# Generado: 2025-10-28 20:45:16

# ==========================================================
# BACKEND
# ==========================================================

https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/app.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/__init__.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/database.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/config/settings.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/extensions.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/cursos.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/leccion.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/multimedia.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/models/usuario.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/__init__.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/actividades_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/auth.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/curso_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/leccion_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/multimedia_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/routes/usuario_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/correo_service.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_cursos.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_lecciones.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_multimedia.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/services/gestor_usuarios.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_password.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/test_routes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/crear_perfiles.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/generar_hashes.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_all_urls_opt.py
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/get_front_end.py

# ==========================================================
# FRONTEND
# ==========================================================

https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/[id]/editar/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/crear/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/[id]/editar/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/asignar-nivel/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/cambiar-curso/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/clasificacion/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/correo-enviado/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/cuenta-desactivada/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/eliminar-cuenta/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/globals.css
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/layout.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/lecciones/[id]/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/lecciones/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/login/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/logros/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/[id]/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/tareas/nueva/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/tareas/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/perfil/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/[id]/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/planificacion/nuevo/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/planificacion/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/retroalimentacion/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/progreso/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/recuperar-contrasena/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/registro/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/restablecer-contrasena/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/restablecer-contrasena/reset-password-content.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/verificar-email/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/admin-stats.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/create-lesson-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/media-library-preview.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/quick-admin-actions.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/recent-lessons.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/level-assignment-flow.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/login-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/recover-password-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/register-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/verify-email-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/dashboard-header.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/progress-overview.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/quick-actions.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/recent-lessons.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/streak-card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/achievements-list.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/leaderboard-filters.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/leaderboard-table.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/level-progress.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/rewards-inventory.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/user-rank-card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/abandon-lesson-modal.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/fill-blank-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/listen-repeat-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/matching-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/multiple-choice-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/translation-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/true-false-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/word-order-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/completion-modal.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-filters.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-list.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-viewer.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/maintenance/create-task-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/profile/profile-settings.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/create-planning-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/quick-teacher-actions.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/recent-feedback.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/response-modal.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/student-performance.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/teacher-stats.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/theme-provider.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/accordion.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/alert-dialog.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/alert.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/aspect-ratio.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/avatar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/badge.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/breadcrumb.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/button-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/button.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/calendar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/carousel.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/chart.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/checkbox.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/collapsible.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/command.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/context-menu.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/dialog.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/drawer.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/dropdown-menu.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/empty.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/field.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/hover-card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input-otp.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/item.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/kbd.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/label.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/menubar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/navigation-menu.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/pagination.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/popover.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/progress.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/radio-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/resizable.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/scroll-area.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/select.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/separator.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sheet.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sidebar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/skeleton.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/slider.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sonner.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/spinner.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/switch.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/table.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/tabs.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/textarea.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toast.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toaster.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toggle-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toggle.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/tooltip.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/use-mobile.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/use-toast.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-mobile.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-toast.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-user-data.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/middleware.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/next-env.d.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/styles/globals.css

# ==========================================================
# DOCS
# ==========================================================

https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/README.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/architecture.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/database.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/errores/bitacoras/ERRORES - 27 OCT 25.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/best-practices.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/naming-conventions.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/requisitos-funcionales.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/workflows/lession-creation.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/workflows/user-registration.md




================================================================================
# ARCHIVO: back-end/url/urls_docs.txt
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/urls_docs.txt
================================================================================

# DOCUMENTACI√ìN - SpeakLexi
# Total: 9 archivos
# Generado: 2025-10-28 20:45:16

https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/README.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/architecture.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/database.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/errores/bitacoras/ERRORES - 27 OCT 25.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/best-practices.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/naming-conventions.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/guidelines/requisitos-funcionales.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/workflows/lession-creation.md
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/docs/workflows/user-registration.md



================================================================================
# ARCHIVO: back-end/url/urls_frontend.txt
# URL: https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/back-end/url/urls_frontend.txt
================================================================================

# FRONTEND - SpeakLexi (Next.js/React/TypeScript)
# Total: 147 archivos
# Generado: 2025-10-28 20:45:16

https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/[id]/editar/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/crear/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/lecciones/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/[id]/editar/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/admin/usuarios/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/asignar-nivel/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/cambiar-curso/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/clasificacion/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/correo-enviado/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/cuenta-desactivada/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/eliminar-cuenta/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/globals.css
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/layout.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/lecciones/[id]/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/lecciones/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/login/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/logros/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/[id]/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/reportes/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/tareas/nueva/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/mantenimiento/tareas/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/perfil/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/dashboard/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/[id]/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/loading.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/estadisticas/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/planificacion/nuevo/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/planificacion/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/profesor/retroalimentacion/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/progreso/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/recuperar-contrasena/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/registro/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/restablecer-contrasena/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/restablecer-contrasena/reset-password-content.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/app/verificar-email/page.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/admin-stats.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/create-lesson-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/media-library-preview.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/quick-admin-actions.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/admin/recent-lessons.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/level-assignment-flow.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/login-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/recover-password-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/register-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/auth/verify-email-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/dashboard-header.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/progress-overview.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/quick-actions.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/recent-lessons.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/dashboard/streak-card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/achievements-list.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/leaderboard-filters.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/leaderboard-table.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/level-progress.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/rewards-inventory.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/gamification/user-rank-card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/abandon-lesson-modal.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/fill-blank-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/listen-repeat-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/matching-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/multiple-choice-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/translation-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/true-false-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/activities/word-order-activity.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/completion-modal.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-filters.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-list.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/lessons/lesson-viewer.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/maintenance/create-task-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/profile/profile-settings.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/create-planning-form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/quick-teacher-actions.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/recent-feedback.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/response-modal.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/student-performance.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/teacher/teacher-stats.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/theme-provider.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/accordion.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/alert-dialog.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/alert.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/aspect-ratio.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/avatar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/badge.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/breadcrumb.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/button-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/button.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/calendar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/carousel.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/chart.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/checkbox.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/collapsible.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/command.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/context-menu.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/dialog.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/drawer.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/dropdown-menu.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/empty.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/field.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/form.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/hover-card.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input-otp.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/input.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/item.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/kbd.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/label.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/menubar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/navigation-menu.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/pagination.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/popover.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/progress.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/radio-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/resizable.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/scroll-area.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/select.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/separator.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sheet.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sidebar.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/skeleton.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/slider.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/sonner.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/spinner.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/switch.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/table.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/tabs.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/textarea.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toast.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toaster.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toggle-group.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/toggle.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/tooltip.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/use-mobile.tsx
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/components/ui/use-toast.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-mobile.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-toast.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/hooks/use-user-data.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/middleware.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/next-env.d.ts
https://raw.githubusercontent.com/sTr4yDev/speakLexi/main/front-end/styles/globals.css


